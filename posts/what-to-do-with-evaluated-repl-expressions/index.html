<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What to Do With Evaluated REPL Expressions? | Well Organized Bits</title>
<meta name=keywords content><meta name=description content="In Clojure, we&rsquo;ve internalized, as Stuart Halloway said, to send things to the REPL, not type into the REPL. The (sub)expressions we send to the REPL live in actual files saved on disk, vs. being ephemeral and tied to a REPL connection. Sometimes, those (sub)expressions come from existing project namespaces. Sometimes, those (sub)expressions don&rsquo;t fit any particular namespace. In that case, Stu&rsquo;s suggestion is to simply append them to everything.clj and evaluate from there."><meta name=author content="Miro Bezjak"><link rel=canonical href=https://mbezjak.github.io/posts/what-to-do-with-evaluated-repl-expressions/><meta name=google-site-verification content="62Vyu3hWVePJQe8DUK8iM3Xn2VdjXAAagXEIxsL5To0"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://mbezjak.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mbezjak.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mbezjak.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mbezjak.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mbezjak.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mbezjak.github.io/posts/what-to-do-with-evaluated-repl-expressions/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="What to Do With Evaluated REPL Expressions?"><meta property="og:description" content="In Clojure, we&rsquo;ve internalized, as Stuart Halloway said, to send things to the REPL, not type into the REPL. The (sub)expressions we send to the REPL live in actual files saved on disk, vs. being ephemeral and tied to a REPL connection. Sometimes, those (sub)expressions come from existing project namespaces. Sometimes, those (sub)expressions don&rsquo;t fit any particular namespace. In that case, Stu&rsquo;s suggestion is to simply append them to everything.clj and evaluate from there."><meta property="og:type" content="article"><meta property="og:url" content="https://mbezjak.github.io/posts/what-to-do-with-evaluated-repl-expressions/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-20T12:31:45+02:00"><meta property="article:modified_time" content="2024-05-20T12:31:45+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="What to Do With Evaluated REPL Expressions?"><meta name=twitter:description content="In Clojure, we&rsquo;ve internalized, as Stuart Halloway said, to send things to the REPL, not type into the REPL. The (sub)expressions we send to the REPL live in actual files saved on disk, vs. being ephemeral and tied to a REPL connection. Sometimes, those (sub)expressions come from existing project namespaces. Sometimes, those (sub)expressions don&rsquo;t fit any particular namespace. In that case, Stu&rsquo;s suggestion is to simply append them to everything.clj and evaluate from there."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mbezjak.github.io/posts/"},{"@type":"ListItem","position":2,"name":"What to Do With Evaluated REPL Expressions?","item":"https://mbezjak.github.io/posts/what-to-do-with-evaluated-repl-expressions/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What to Do With Evaluated REPL Expressions?","name":"What to Do With Evaluated REPL Expressions?","description":"In Clojure, we\u0026rsquo;ve internalized, as Stuart Halloway said, to send things to the REPL, not type into the REPL. The (sub)expressions we send to the REPL live in actual files saved on disk, vs. being ephemeral and tied to a REPL connection. Sometimes, those (sub)expressions come from existing project namespaces. Sometimes, those (sub)expressions don\u0026rsquo;t fit any particular namespace. In that case, Stu\u0026rsquo;s suggestion is to simply append them to everything.clj and evaluate from there.","keywords":[],"articleBody":"In Clojure, we’ve internalized, as Stuart Halloway said, to send things to the REPL, not type into the REPL. The (sub)expressions we send to the REPL live in actual files saved on disk, vs. being ephemeral and tied to a REPL connection. Sometimes, those (sub)expressions come from existing project namespaces. Sometimes, those (sub)expressions don’t fit any particular namespace. In that case, Stu’s suggestion is to simply append them to everything.clj and evaluate from there. That works quite well! If you’re not doing that, consider starting.\nOver the years of using an equivalent of everything.clj, I’ve observed a few things:\nCertain (sub)expressions are reusable, or can be made reusable. Enough for me, but not necessarily enough for them to be included in dev/user.clj. Sometimes, a (sub)expression I wrote a while back is almost (maybe with slight modification) exactly what I need now. Coworkers might ask for how I do things. This leads to copy/pasting (sub)expressions to Slack, GitHub PRs, etc. Based on above, I’d like to recommend an addition to Stu’s suggestion.\nCommit those file(s) to project’s git repository under your name 1\nFor example:\n$ tree repl/ repl/ └── miro ├── everything.clj └── reuse.clj Every other developer, willing to partake, could put their stuff into repl/$name directory. This might also be the place for those debugging helpers.\nSuggested rules for repl/* Don’t add repl/* to the classpath. Don’t review code in repl/*. When changing src, there is no need to change repl/*. Especially someone else’s REPL scripts! There is no guarantee that the code in repl/* works. Setup your editor/IDE to ignore searching text in repl/*. The point of everything.clj is to send individual expressions to the REPL and not the whole file. Adding those files to the classpath would send the wrong message. To use functions from reuse.clj in everything.clj simply load the whole file with clojure.core/load-file.\nThe code in repl/* is mostly write-and-evaluate-once (with few exceptions). There is no need to expand the effort into making those expressions work again after an incompatible change to src. The effort to fix the expression should only be made when you (or someone else) have the need to evaluate it again.\nIn fact, there is no guarantee that any particular expression will work. Some might; some might require a tweak or two; some might be completely broken. The value of having them is that you don’t need to start from scratch. Feel free to delete the code that will obviously not be useful anymore. Also feel free to share certain expressions with your coworkers. With the files committed to git, you can simply give them the permalink of the expression.\nAccept any change in the PR coming from repl/* as-is. It’s not production code, it’s not on the classpath, and won’t enter production in any way. It’s safe to simply accept someone else’s experiments.\nFinally, you might rely on certain tools or IDEs that search for a given text across all text files in the project. Make sure to exclude repl/* files when searching to avoid superfluous lines.\nAppendix: an example An example of how the top of everything.clj might look like. The top might be include something you’re using every now and again.\n(load-file \"repl/miro/reuse.clj\") (reuse/start-unless-already-started) (reuse/connect-flow-storm) (reuse/start-quietly) (reuse/restore-logging) (reuse/stop-job-executors) (reuse/run-job-now :integrity-check) (reuse/run-all-migrations) (reuse/execute-sql-across-all-dbs-and-schemas [\"DELETE TABLE IF EXISTS recently_added\"]) (reuse/simulate-time-passed 1-day) (reuse/delete-all db) (reuse/bootstrap-the-usually-things db) (reuse/request-body-as-clojure \"/tmp/captured.json\") The bottom might be a recent experiment. The code isn’t meant to be production quality. Comments added for the reader.\n;; What's the result? (time-format/parse-local-date \"2024-04-24T00:00:00.000Z\") (time-format/parse-local-date \"2024-04-23T23:59:59.000Z\") ;; Which formatters are available? time-format/formatters (time-format/show-formatters) ;; What's my local time zone? (time/now) (java.util.Date.) (System/getProperty \"user.timezone\") (java.util.TimeZone/getDefault) ;; Which formatter is the first that parses successfully? (doseq [formatter-name (map #(get (set/map-invert time-format/formatters) %) (vals time-format/formatters))] (try (println \"Succeeded\" formatter-name (time-format/parse-local-date (get time-format/formatters formatter-name) \"2024-04-24T00:00:00.000Z\")) (catch Exception e (println \"Failed \" formatter-name)))) Depending on if you use a monorepo or multirepo, this might mean multiple everything.clj files. In that case, everything.clj is not necessarily referring to a global “everything”, but “everything” for that particular project. ↩︎\n","wordCount":"670","inLanguage":"en","datePublished":"2024-05-20T12:31:45+02:00","dateModified":"2024-05-20T12:31:45+02:00","author":{"@type":"Person","name":"Miro Bezjak"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mbezjak.github.io/posts/what-to-do-with-evaluated-repl-expressions/"},"publisher":{"@type":"Organization","name":"Well Organized Bits","logo":{"@type":"ImageObject","url":"https://mbezjak.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mbezjak.github.io/ accesskey=h title="Well Organized Bits (Alt + H)">Well Organized Bits</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mbezjak.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=mailto:well.organized.bits@proton.me title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mbezjak.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://mbezjak.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">What to Do With Evaluated REPL Expressions?</h1><div class=post-meta><span title='2024-05-20 12:31:45 +0200 +0200'>May 20, 2024</span>&nbsp;·&nbsp;Miro Bezjak&nbsp;|&nbsp;<a href=https://github.com/mbezjak/mbezjak.github.io/blob/main/content/posts/what-to-do-with-evaluated-repl-expressions.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>In Clojure, we&rsquo;ve internalized, as Stuart Halloway said, to <a href=https://vimeo.com/223309989>send things to the REPL, not type into
the REPL</a>. The (sub)expressions we send to the REPL live in actual
files saved on disk, vs. being ephemeral and tied to a REPL connection. Sometimes, those
(sub)expressions come from existing project namespaces. Sometimes, those (sub)expressions don&rsquo;t fit
any particular namespace. In that case, Stu&rsquo;s suggestion is to simply append them to
<code>everything.clj</code> and evaluate from there. That works quite well! If you&rsquo;re not doing that, consider
starting.</p><p>Over the years of using an equivalent of <code>everything.clj</code>, I&rsquo;ve observed a few things:</p><ol><li>Certain (sub)expressions are reusable, or can be made reusable. Enough for me, but not
necessarily enough for them to be included in <code>dev/user.clj</code>.</li><li>Sometimes, a (sub)expression I wrote a while back is almost (maybe with slight modification)
exactly what I need now.</li><li>Coworkers might ask for how I do things. This leads to copy/pasting (sub)expressions to Slack,
GitHub PRs, etc.</li></ol><p>Based on above, I&rsquo;d like to recommend an addition to Stu&rsquo;s suggestion.</p><blockquote><p>Commit those file(s) to project&rsquo;s git repository under your name <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p></blockquote><p>For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ tree repl/
</span></span><span style=display:flex><span>repl/
</span></span><span style=display:flex><span>└── miro
</span></span><span style=display:flex><span>    ├── everything.clj
</span></span><span style=display:flex><span>    └── reuse.clj
</span></span></code></pre></div><p>Every other developer, willing to partake, could put their stuff into <code>repl/$name</code> directory. This
might also be the place for those <a href=../clojure-debugging-helpers>debugging helpers</a>.</p><h2 id=suggested-rules-for-repl>Suggested rules for <code>repl/*</code><a hidden class=anchor aria-hidden=true href=#suggested-rules-for-repl>#</a></h2><ol><li>Don&rsquo;t add <code>repl/*</code> to the classpath.</li><li>Don&rsquo;t review code in <code>repl/*</code>.</li><li>When changing <code>src</code>, there is no need to change <code>repl/*</code>. Especially someone else&rsquo;s REPL scripts!</li><li>There is no guarantee that the code in <code>repl/*</code> works.</li><li>Setup your editor/IDE to ignore searching text in <code>repl/*</code>.</li></ol><p>The point of <code>everything.clj</code> is to send individual expressions to the REPL and not the whole file.
Adding those files to the classpath would send the wrong message. To use functions from <code>reuse.clj</code>
in <code>everything.clj</code> simply load the whole file with <code>clojure.core/load-file</code>.</p><p>The code in <code>repl/*</code> is mostly write-and-evaluate-once (with few exceptions). There is no need to
expand the effort into making those expressions work again after an incompatible change to <code>src</code>.
The effort to fix the expression should only be made when you (or someone else) have the <strong>need</strong> to
evaluate it again.</p><p>In fact, there is no guarantee that any particular expression will work. Some might; some might
require a tweak or two; some might be completely broken. The value of having them is that you don&rsquo;t
need to start from scratch. Feel free to delete the code that will obviously not be useful anymore.
Also feel free to share certain expressions with your coworkers. With the files committed to git,
you can simply give them the permalink of the expression.</p><p>Accept any change in the PR coming from <code>repl/*</code> as-is. It&rsquo;s not production code, it&rsquo;s not on the
classpath, and won&rsquo;t enter production in any way. It&rsquo;s safe to simply accept someone else&rsquo;s
experiments.</p><p>Finally, you might rely on certain tools or IDEs that search for a given text across all text files
in the project. Make sure to exclude <code>repl/*</code> files when searching to avoid superfluous lines.</p><h2 id=appendix-an-example>Appendix: an example<a hidden class=anchor aria-hidden=true href=#appendix-an-example>#</a></h2><p>An example of how the top of <code>everything.clj</code> might look like. The top might be include something
you&rsquo;re using every now and again.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(load-file <span style=color:#e6db74>&#34;repl/miro/reuse.clj&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>reuse/start-unless-already-started</span>)
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>reuse/connect-flow-storm</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>reuse/start-quietly</span>)
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>reuse/restore-logging</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>reuse/stop-job-executors</span>)
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>reuse/run-job-now</span> <span style=color:#e6db74>:integrity-check</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>reuse/run-all-migrations</span>)
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>reuse/execute-sql-across-all-dbs-and-schemas</span> [<span style=color:#e6db74>&#34;DELETE TABLE IF EXISTS recently_added&#34;</span>])
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>reuse/simulate-time-passed</span> <span style=color:#ae81ff>1</span>-day)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>reuse/delete-all</span> db)
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>reuse/bootstrap-the-usually-things</span> db)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>reuse/request-body-as-clojure</span> <span style=color:#e6db74>&#34;/tmp/captured.json&#34;</span>)
</span></span></code></pre></div><p>The bottom might be a recent experiment. The code isn&rsquo;t meant to be production quality. Comments
added for the reader.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span><span style=color:#75715e>;; What&#39;s the result?</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>time-format/parse-local-date</span> <span style=color:#e6db74>&#34;2024-04-24T00:00:00.000Z&#34;</span>)
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>time-format/parse-local-date</span> <span style=color:#e6db74>&#34;2024-04-23T23:59:59.000Z&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; Which formatters are available?</span>
</span></span><span style=display:flex><span>time-format/formatters
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>time-format/show-formatters</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; What&#39;s my local time zone?</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>time/now</span>)
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>java.util.Date.</span>)
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>System/getProperty</span> <span style=color:#e6db74>&#34;user.timezone&#34;</span>)
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>java.util.TimeZone/getDefault</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; Which formatter is the first that parses successfully?</span>
</span></span><span style=display:flex><span>(doseq [formatter-name (map <span style=color:#f92672>#</span>(get (<span style=color:#a6e22e>set/map-invert</span> time-format/formatters) %)
</span></span><span style=display:flex><span>                            (vals time-format/formatters))]
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>try</span>
</span></span><span style=display:flex><span>    (println <span style=color:#e6db74>&#34;Succeeded&#34;</span> formatter-name
</span></span><span style=display:flex><span>             (<span style=color:#a6e22e>time-format/parse-local-date</span> (get time-format/formatters formatter-name)
</span></span><span style=display:flex><span>                                           <span style=color:#e6db74>&#34;2024-04-24T00:00:00.000Z&#34;</span>))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>catch</span> Exception e
</span></span><span style=display:flex><span>      (println <span style=color:#e6db74>&#34;Failed &#34;</span> formatter-name))))
</span></span></code></pre></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Depending on if you use a monorepo or multirepo, this might mean multiple <code>everything.clj</code>
files. In that case, <code>everything.clj</code> is not necessarily referring to a global &ldquo;everything&rdquo;, but
&ldquo;everything&rdquo; for that particular project.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://mbezjak.github.io/>Well Organized Bits</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>