<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Errors From Libraries | Well Organized Bits</title><meta name=keywords content><meta name=description content="At this point, we&rsquo;ve defined the error model and know how to use it. Until now, we focused on custom validations in the project. However, what if the errors originate in the libraries you might be using for some validation? Open-source libraries cannot possibly know about your own error model. They have their way of representing and returning errors. We hinted at the solution already - convert library errors into your own model."><meta name=author content="Miro Bezjak"><link rel=canonical href=https://mbezjak.github.io/posts/errors-from-libraries/><meta name=google-site-verification content="62Vyu3hWVePJQe8DUK8iM3Xn2VdjXAAagXEIxsL5To0"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://mbezjak.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mbezjak.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mbezjak.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mbezjak.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mbezjak.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Errors From Libraries"><meta property="og:description" content="At this point, we&rsquo;ve defined the error model and know how to use it. Until now, we focused on custom validations in the project. However, what if the errors originate in the libraries you might be using for some validation? Open-source libraries cannot possibly know about your own error model. They have their way of representing and returning errors. We hinted at the solution already - convert library errors into your own model."><meta property="og:type" content="article"><meta property="og:url" content="https://mbezjak.github.io/posts/errors-from-libraries/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-13T18:00:24+01:00"><meta property="article:modified_time" content="2023-01-13T18:00:24+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Errors From Libraries"><meta name=twitter:description content="At this point, we&rsquo;ve defined the error model and know how to use it. Until now, we focused on custom validations in the project. However, what if the errors originate in the libraries you might be using for some validation? Open-source libraries cannot possibly know about your own error model. They have their way of representing and returning errors. We hinted at the solution already - convert library errors into your own model."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://mbezjak.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Errors From Libraries","item":"https://mbezjak.github.io/posts/errors-from-libraries/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Errors From Libraries","name":"Errors From Libraries","description":"At this point, we\u0026rsquo;ve defined the error model and know how to use it. Until now, we focused on custom validations in the project. However, what if the errors originate in the libraries you might be using for some validation? Open-source libraries cannot possibly know about your own error model. They have their way of representing and returning errors. We hinted at the solution already - convert library errors into your own model.","keywords":[],"articleBody":"At this point, we’ve defined the error model and know how to use it. Until now, we focused on custom validations in the project. However, what if the errors originate in the libraries you might be using for some validation? Open-source libraries cannot possibly know about your own error model. They have their way of representing and returning errors. We hinted at the solution already - convert library errors into your own model. Let’s do that here.\nI’ll use malli as an example, but the same idea can be applied to any other library you might be using.\nClojure spec Plumatic schema buddy.sign.jwt/unsign etc. Conversion For clarity, let’s reiterate what we want to achieve.\nWe want to have one error representation - our own error model. This makes dealing with errors simple. We want errors to collect as much information as possible to make debugging easier. Remember that the error model is an in-memory model. It doesn’t necessarily mean that everything you collect is going to be used as an HTTP response. We want to carry that information to the code that can decide what it’s going to do with it. Perhaps it’ll use a subset of that information to respond to an HTTP request, log the error, collect metrics, write to DB, etc. How to do that for an external library? By wrapping. If some function returns that library’s error representation then convert it on the fly to our own error model.\nFor completeness, let’s just state the obvious. Wrapping every function in that library is not the goal. The library is not the problem. “Non-standard” error representation is. For example, malli.core/validate is not a good candidate for wrapping. It’s a reasonable function to call when you only want a yes or no answer, but the boolean result is not something that can be usefully converted to own error model. Keep those calls in your project as they are.\n(malli/validate [:string] \"1\") =\u003e true (malli/validate [:string] 1) =\u003e false The perfect candidate is malli.core/explain.\n(malli/explain [:map [:user [:map {:closed true} [:first-name :string] [:last-name :string]]]] {:user {:first-name \"John\" :last-name \"Doe\"}}) =\u003e nil (malli/explain [:map [:user [:map {:closed true} [:first-name :string] [:last-name :string]]]] {:user {:name \"John Doe\"}}) =\u003e {:schema [:map [:user [:map {:closed true} [:first-name :string] [:last-name :string]]]] :value {:user {:name \"John Doe\"}} :errors '({:path [:user :first-name] :in [:user :first-name] :schema [:map {:closed true} [:first-name :string] [:last-name :string]] :value nil :type :malli.core/missing-key} {:path [:user :last-name] :in [:user :last-name] :schema [:map {:closed true} [:first-name :string] [:last-name :string]] :value nil :type :malli.core/missing-key} {:path [:user :name] :in [:user :name] :schema [:map {:closed true} [:first-name :string] [:last-name :string]] :value \"John Doe\" :type :malli.core/extra-key})} The hash-map that malli.core/explain returns is what we would like to convert to our own error model.\nThat seems simple enough. It’s just a transformation from one data type into another. We just need to keep in mind that malli comes with a lot of built-in schemas. Here is a snippet of what that transformation would look like.\nmalli_validator.clj\n,,, (def ^:private malli-code-\u003eerror-code {'nil? :malli/null 'some? :malli/some 'boolean? :malli/boolean 'true? :malli/true 'false? :malli/false 'number? :malli/number ::malli/missing-key :malli/required ::malli/extra-key :malli/extra-key ,,,}) (defn- malli-\u003eerror [root-schema root-value malli-error] ,,, (assoc-breadcrumb-info (merge {::root-schema root-schema ::root-value root-value ::schema error-schema ::value error-value ::path (:path malli-error) ::in (:in malli-error)} (if-let [type (:type malli-error)] {:code (get malli-code-\u003eerror-code type)} {:code (get malli-code-\u003eerror-code schema-type)}) ,,,))) (defn validate [schema value] (when-let [{:keys [schema value errors]} (malli/explain schema value)] (-\u003e\u003e errors (map #(malli-\u003eerror schema value %)) (errors/make)))) Given that we’re referring to the error message via :code, we also need the error templates.\nresources/error-templates.edn\n{:malli/required \"%s is required\" :malli/extra-key \"System doesn't recognize property %s\" :malli/null \"%s must be empty\" :malli/some \"%s must not be null\" :malli/boolean \"%s must be a boolean\" :malli/true \"%s must have a value of `true`\" :malli/false \"%s must have a value of `false`\" :malli/number \"%s must be a number\" ,,,} That is the core idea. It’s relatively simple. To complete the above we’d need to take a look at the malli’s implementation because the documentation doesn’t describe everything we need to know to complete it.\nOr you can just refer to the full implementation below.\nMalli validator The full implementation with tests and error templates is here: https://gist.github.com/mbezjak/a76b737cd6330e60b60c78b7e2c8fb9e\nNotes regarding the implementation:\nThe implementation is compatible with malli 0.9.2. Latest at the time of this writing. malli-code-\u003eerror-code might be sensitive to malli’s internal implementation (or breaking changes). E.g. new malli version might add or remove a schema. To guard against that, just call malli-validator/check-compatibility-with-malli! at the start of your integration tests (or system start). It’s used to check if malli-validator is still in sync after you’ve updated malli. The implementation includes the automatic generation of args, human (developer) breadcrumbs, and error templates with certain wording. It’s geared towards both HTTP service response as well as responding to a web application with the intent of displaying it to the customer (mostly as a global toast element vs. below the form field). Feel free to modify malli-validator and templates to suit your need. Refer to clojure.core extensions for some of the functions used in the implementation. Alternative implementation You might be using malli.error/humanize in your project.\n(me/humanize (malli/explain [:map [:user [:map {:closed true} [:first-name :string] [:last-name :string]]]] {:user {:name \"John Doe\"}})) =\u003e {:user {:first-name [\"missing required key\"] :last-name [\"missing required key\"] :name [\"disallowed key\"]}} Can that be used instead of malli.core/explain to generate own error model? Yes, it can! The only problem is that you’d be throwing a lot of information. For example, malli.core/explain gives you very nested schemas and values that failed, not just the root schema and value. Besides that, you’d be losing the programmatic access to why an int or string failed the validation: is it due to min/max constraints, is it null, type mismatch, etc? With humanize that information is embedded inside of the error message itself, while with explain it can be embedded both in the error message and as a specific :code (e.g. :malli/required, :malli/string, :malli/string-with-length-between, :malli/string-with-length-max, :malli/string-with-length-min). However, if you don’t care about that information (not even while debugging?) then you can use the result from humanize. Just be aware that the result is not a simple “property -\u003e vector-of-messages” hash-map, but can be nested as indicated in the example above.\nYou could even combine the results of malli.core/explain and malli.error/humanize to collect all of the information from explain, but also reuse the error messages from humanize. This could get rid of duplicated templates between error-template.edn and malli.error/default-errors. Feel free to consider if this is worthwhile for your project.\nWhat to do with the errors? (let [errors (malli-validator/validate schema value)] ,,,) Now that we have the errors, what do we do with them? We are in the same situation as before. Please see the previous suggestion.\n","wordCount":"1121","inLanguage":"en","datePublished":"2023-01-13T18:00:24+01:00","dateModified":"2023-01-13T18:00:24+01:00","author":{"@type":"Person","name":"Miro Bezjak"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mbezjak.github.io/posts/errors-from-libraries/"},"publisher":{"@type":"Organization","name":"Well Organized Bits","logo":{"@type":"ImageObject","url":"https://mbezjak.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mbezjak.github.io accesskey=h title="Well Organized Bits (Alt + H)">Well Organized Bits</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mbezjak.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=mailto:well.organized.bits@proton.me title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mbezjak.github.io>Home</a>&nbsp;»&nbsp;<a href=https://mbezjak.github.io/posts/>Posts</a></div><h1 class=post-title>Errors From Libraries</h1><div class=post-meta><span title='2023-01-13 18:00:24 +0100 +0100'>January 13, 2023</span>&nbsp;·&nbsp;Miro Bezjak&nbsp;|&nbsp;<a href=https://github.com/mbezjak/mbezjak.github.io/blob/main/content/posts/errors-from-libraries.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>At this point, we&rsquo;ve <a href=../error-model>defined the error model</a> and <a href=../using-the-error-model>know how to
use it</a>. Until now, we focused on <em>custom</em> validations
in the project. However, what if the errors originate in the libraries you might
be using for <a href=../what-is-a-validation#what-can-result-in-an-error>some
validation</a>? Open-source
libraries cannot possibly know about your own error model. They have their way
of representing and returning errors. We hinted at the solution already -
<a href=../error-model#how-to-use-it>convert library errors into your own model</a>.
Let&rsquo;s do that here.</p><p>I&rsquo;ll use <a href=https://github.com/metosin/malli>malli</a> as an example, but the same
idea can be applied to any other library you might be using.</p><ul><li><a href=https://clojure.org/guides/spec>Clojure spec</a></li><li><a href=https://github.com/plumatic/schema>Plumatic schema</a></li><li><a href=https://github.com/funcool/buddy-sign/blob/3.4.333/src/buddy/sign/jwt.clj#L22>buddy.sign.jwt/unsign</a></li><li>etc.</li></ul><h2 id=conversion>Conversion<a hidden class=anchor aria-hidden=true href=#conversion>#</a></h2><p>For clarity, let&rsquo;s reiterate what we want to achieve.</p><ul><li>We want to have one error representation - our own error model. This makes
dealing with errors simple.</li><li>We want errors to collect as much information as possible to make debugging
easier. Remember that the error model is an in-memory model. It doesn&rsquo;t
necessarily mean that everything you collect is going to be used as an HTTP
response.</li><li>We want to carry that information to the code that can decide what it&rsquo;s going
to do with it. Perhaps it&rsquo;ll use a subset of that information to respond to an
HTTP request, log the error, collect metrics, write to DB, etc.</li></ul><p>How to do that for an external library? By wrapping. If some function returns
that library&rsquo;s error representation then convert it on the fly to our own error
model.</p><p>For completeness, let&rsquo;s just state the obvious. Wrapping every function in that
library is not the goal. The library is not the problem. &ldquo;Non-standard&rdquo; error
representation is. For example, <code>malli.core/validate</code> is not a good candidate
for wrapping. It&rsquo;s a reasonable function to call when you only want a yes or no
answer, but the boolean result is not something that can be usefully converted
to own error model. Keep those calls in your project as they are.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>malli/validate</span> [<span style=color:#e6db74>:string</span>] <span style=color:#e6db74>&#34;1&#34;</span>)
</span></span><span style=display:flex><span>=&gt; true
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>malli/validate</span> [<span style=color:#e6db74>:string</span>] <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>=&gt; false
</span></span></code></pre></div><p>The perfect candidate is <code>malli.core/explain</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>malli/explain</span> [<span style=color:#e6db74>:map</span>
</span></span><span style=display:flex><span>                [<span style=color:#e6db74>:user</span> [<span style=color:#e6db74>:map</span> {<span style=color:#e6db74>:closed</span> true}
</span></span><span style=display:flex><span>                        [<span style=color:#e6db74>:first-name</span> <span style=color:#e6db74>:string</span>]
</span></span><span style=display:flex><span>                        [<span style=color:#e6db74>:last-name</span> <span style=color:#e6db74>:string</span>]]]]
</span></span><span style=display:flex><span>               {<span style=color:#e6db74>:user</span> {<span style=color:#e6db74>:first-name</span> <span style=color:#e6db74>&#34;John&#34;</span>
</span></span><span style=display:flex><span>                       <span style=color:#e6db74>:last-name</span> <span style=color:#e6db74>&#34;Doe&#34;</span>}})
</span></span><span style=display:flex><span>=&gt; nil
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>malli/explain</span> [<span style=color:#e6db74>:map</span>
</span></span><span style=display:flex><span>                [<span style=color:#e6db74>:user</span> [<span style=color:#e6db74>:map</span> {<span style=color:#e6db74>:closed</span> true}
</span></span><span style=display:flex><span>                        [<span style=color:#e6db74>:first-name</span> <span style=color:#e6db74>:string</span>]
</span></span><span style=display:flex><span>                        [<span style=color:#e6db74>:last-name</span> <span style=color:#e6db74>:string</span>]]]]
</span></span><span style=display:flex><span>               {<span style=color:#e6db74>:user</span> {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;John Doe&#34;</span>}})
</span></span><span style=display:flex><span>=&gt;
</span></span><span style=display:flex><span>{<span style=color:#e6db74>:schema</span> [<span style=color:#e6db74>:map</span> [<span style=color:#e6db74>:user</span> [<span style=color:#e6db74>:map</span> {<span style=color:#e6db74>:closed</span> true} [<span style=color:#e6db74>:first-name</span> <span style=color:#e6db74>:string</span>] [<span style=color:#e6db74>:last-name</span> <span style=color:#e6db74>:string</span>]]]]
</span></span><span style=display:flex><span> <span style=color:#e6db74>:value</span> {<span style=color:#e6db74>:user</span> {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;John Doe&#34;</span>}}
</span></span><span style=display:flex><span> <span style=color:#e6db74>:errors</span> <span style=color:#f92672>&#39;</span>({<span style=color:#e6db74>:path</span> [<span style=color:#e6db74>:user</span> <span style=color:#e6db74>:first-name</span>]
</span></span><span style=display:flex><span>            <span style=color:#e6db74>:in</span> [<span style=color:#e6db74>:user</span> <span style=color:#e6db74>:first-name</span>]
</span></span><span style=display:flex><span>            <span style=color:#e6db74>:schema</span> [<span style=color:#e6db74>:map</span> {<span style=color:#e6db74>:closed</span> true} [<span style=color:#e6db74>:first-name</span> <span style=color:#e6db74>:string</span>] [<span style=color:#e6db74>:last-name</span> <span style=color:#e6db74>:string</span>]]
</span></span><span style=display:flex><span>            <span style=color:#e6db74>:value</span> nil
</span></span><span style=display:flex><span>            <span style=color:#e6db74>:type</span> <span style=color:#e6db74>:malli.core/missing-key</span>}
</span></span><span style=display:flex><span>           {<span style=color:#e6db74>:path</span> [<span style=color:#e6db74>:user</span> <span style=color:#e6db74>:last-name</span>]
</span></span><span style=display:flex><span>            <span style=color:#e6db74>:in</span> [<span style=color:#e6db74>:user</span> <span style=color:#e6db74>:last-name</span>]
</span></span><span style=display:flex><span>            <span style=color:#e6db74>:schema</span> [<span style=color:#e6db74>:map</span> {<span style=color:#e6db74>:closed</span> true} [<span style=color:#e6db74>:first-name</span> <span style=color:#e6db74>:string</span>] [<span style=color:#e6db74>:last-name</span> <span style=color:#e6db74>:string</span>]]
</span></span><span style=display:flex><span>            <span style=color:#e6db74>:value</span> nil
</span></span><span style=display:flex><span>            <span style=color:#e6db74>:type</span> <span style=color:#e6db74>:malli.core/missing-key</span>}
</span></span><span style=display:flex><span>           {<span style=color:#e6db74>:path</span> [<span style=color:#e6db74>:user</span> <span style=color:#e6db74>:name</span>]
</span></span><span style=display:flex><span>            <span style=color:#e6db74>:in</span> [<span style=color:#e6db74>:user</span> <span style=color:#e6db74>:name</span>]
</span></span><span style=display:flex><span>            <span style=color:#e6db74>:schema</span> [<span style=color:#e6db74>:map</span> {<span style=color:#e6db74>:closed</span> true} [<span style=color:#e6db74>:first-name</span> <span style=color:#e6db74>:string</span>] [<span style=color:#e6db74>:last-name</span> <span style=color:#e6db74>:string</span>]]
</span></span><span style=display:flex><span>            <span style=color:#e6db74>:value</span> <span style=color:#e6db74>&#34;John Doe&#34;</span>
</span></span><span style=display:flex><span>            <span style=color:#e6db74>:type</span> <span style=color:#e6db74>:malli.core/extra-key</span>})}
</span></span></code></pre></div><p>The hash-map that <code>malli.core/explain</code> returns is what we would like to convert
to our <a href=../error-model#model-that-works-well-enough>own error model</a>.</p><p>That seems simple enough. It&rsquo;s just a transformation from one data type into
another. We just need to keep in mind that malli comes with a lot of <a href=https://github.com/metosin/malli#built-in-schemas>built-in
schemas</a>. Here is a snippet
of what that transformation would look like.</p><p><code>malli_validator.clj</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>,,,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>def </span><span style=color:#f92672>^</span><span style=color:#e6db74>:private</span> malli-code-&gt;error-code
</span></span><span style=display:flex><span>  {<span style=color:#e6db74>&#39;nil?</span> <span style=color:#e6db74>:malli/null</span>
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;some?</span> <span style=color:#e6db74>:malli/some</span>
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;boolean?</span> <span style=color:#e6db74>:malli/boolean</span>
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;true?</span> <span style=color:#e6db74>:malli/true</span>
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;false?</span> <span style=color:#e6db74>:malli/false</span>
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#39;number?</span> <span style=color:#e6db74>:malli/number</span>
</span></span><span style=display:flex><span>   <span style=color:#e6db74>::malli/missing-key</span> <span style=color:#e6db74>:malli/required</span>
</span></span><span style=display:flex><span>   <span style=color:#e6db74>::malli/extra-key</span> <span style=color:#e6db74>:malli/extra-key</span>
</span></span><span style=display:flex><span>   ,,,})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn- </span>malli-&gt;error [root-schema root-value malli-error]
</span></span><span style=display:flex><span>  ,,,
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>assoc-breadcrumb-info</span>
</span></span><span style=display:flex><span>   (merge {<span style=color:#e6db74>::root-schema</span> root-schema
</span></span><span style=display:flex><span>           <span style=color:#e6db74>::root-value</span> root-value
</span></span><span style=display:flex><span>           <span style=color:#e6db74>::schema</span> error-schema
</span></span><span style=display:flex><span>           <span style=color:#e6db74>::value</span> error-value
</span></span><span style=display:flex><span>           <span style=color:#e6db74>::path</span> (<span style=color:#e6db74>:path</span> malli-error)
</span></span><span style=display:flex><span>           <span style=color:#e6db74>::in</span> (<span style=color:#e6db74>:in</span> malli-error)}
</span></span><span style=display:flex><span>          (if-let [type (<span style=color:#e6db74>:type</span> malli-error)]
</span></span><span style=display:flex><span>            {<span style=color:#e6db74>:code</span> (get malli-code-&gt;error-code type)}
</span></span><span style=display:flex><span>            {<span style=color:#e6db74>:code</span> (get malli-code-&gt;error-code schema-type)})
</span></span><span style=display:flex><span>          ,,,)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>validate [schema value]
</span></span><span style=display:flex><span>  (when-let [{<span style=color:#e6db74>:keys</span> [schema value errors]} (<span style=color:#a6e22e>malli/explain</span> schema value)]
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>-&gt;&gt;</span> errors
</span></span><span style=display:flex><span>         (map <span style=color:#f92672>#</span>(<span style=color:#a6e22e>malli-&gt;error</span> schema value %))
</span></span><span style=display:flex><span>         (<span style=color:#a6e22e>errors/make</span>))))
</span></span></code></pre></div><p>Given that we&rsquo;re referring to the error message via <code>:code</code>, we also need the
<a href=../error-model#code-and-args>error templates</a>.</p><p><code>resources/error-templates.edn</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>{<span style=color:#e6db74>:malli/required</span> <span style=color:#e6db74>&#34;%s is required&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:malli/extra-key</span> <span style=color:#e6db74>&#34;System doesn&#39;t recognize property %s&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:malli/null</span> <span style=color:#e6db74>&#34;%s must be empty&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:malli/some</span> <span style=color:#e6db74>&#34;%s must not be null&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:malli/boolean</span> <span style=color:#e6db74>&#34;%s must be a boolean&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:malli/true</span> <span style=color:#e6db74>&#34;%s must have a value of `true`&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:malli/false</span> <span style=color:#e6db74>&#34;%s must have a value of `false`&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:malli/number</span> <span style=color:#e6db74>&#34;%s must be a number&#34;</span>
</span></span><span style=display:flex><span> ,,,}
</span></span></code></pre></div><p>That is the core idea. It&rsquo;s relatively simple. To complete the above we&rsquo;d need
to take a look at the malli&rsquo;s implementation because the documentation doesn&rsquo;t
describe everything we need to know to complete it.</p><p>Or you can just refer to the full implementation below.</p><h2 id=malli-validator>Malli validator<a hidden class=anchor aria-hidden=true href=#malli-validator>#</a></h2><p>The full implementation with tests and error templates is here:
<a href=https://gist.github.com/mbezjak/a76b737cd6330e60b60c78b7e2c8fb9e>https://gist.github.com/mbezjak/a76b737cd6330e60b60c78b7e2c8fb9e</a></p><p>Notes regarding the implementation:</p><ul><li>The implementation is compatible with malli 0.9.2. Latest at the time of this
writing.</li><li><code>malli-code->error-code</code> might be sensitive to malli&rsquo;s internal implementation
(or breaking changes). E.g. new malli version might add or remove a schema. To
guard against that, just call
<code>malli-validator/check-compatibility-with-malli!</code> at the start of your
integration tests (or system start). It&rsquo;s used to check if <code>malli-validator</code>
is still in sync after you&rsquo;ve updated malli.</li><li>The implementation includes the automatic generation of <code>args</code>, human
(developer) breadcrumbs, and error templates with certain wording. It&rsquo;s geared
towards both HTTP service response as well as responding to a web application
with the intent of displaying it to the customer (mostly as a global toast
element vs. below the form field). Feel free to modify <code>malli-validator</code> and
templates to suit your need.</li><li>Refer to <a href=../clojure-core-extensions>clojure.core extensions</a> for some of the
functions used in the implementation.</li></ul><h2 id=alternative-implementation>Alternative implementation<a hidden class=anchor aria-hidden=true href=#alternative-implementation>#</a></h2><p>You might be using <code>malli.error/humanize</code> in your project.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>me/humanize</span>
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>malli/explain</span> [<span style=color:#e6db74>:map</span>
</span></span><span style=display:flex><span>                 [<span style=color:#e6db74>:user</span> [<span style=color:#e6db74>:map</span> {<span style=color:#e6db74>:closed</span> true}
</span></span><span style=display:flex><span>                         [<span style=color:#e6db74>:first-name</span> <span style=color:#e6db74>:string</span>]
</span></span><span style=display:flex><span>                         [<span style=color:#e6db74>:last-name</span> <span style=color:#e6db74>:string</span>]]]]
</span></span><span style=display:flex><span>                {<span style=color:#e6db74>:user</span> {<span style=color:#e6db74>:name</span> <span style=color:#e6db74>&#34;John Doe&#34;</span>}}))
</span></span><span style=display:flex><span>=&gt;
</span></span><span style=display:flex><span>{<span style=color:#e6db74>:user</span> {<span style=color:#e6db74>:first-name</span> [<span style=color:#e6db74>&#34;missing required key&#34;</span>]
</span></span><span style=display:flex><span>        <span style=color:#e6db74>:last-name</span> [<span style=color:#e6db74>&#34;missing required key&#34;</span>]
</span></span><span style=display:flex><span>        <span style=color:#e6db74>:name</span> [<span style=color:#e6db74>&#34;disallowed key&#34;</span>]}}
</span></span></code></pre></div><p>Can that be used instead of <code>malli.core/explain</code> to generate own error model?
Yes, it can! The only problem is that you&rsquo;d be throwing a lot of information.
For example, <code>malli.core/explain</code> gives you very nested schemas and values that
failed, not just the root schema and value. Besides that, you&rsquo;d be losing the
programmatic access to why an int or string failed the validation: is it due to
min/max constraints, is it null, type mismatch, etc? With <code>humanize</code> that
information is embedded inside of the error message itself, while with <code>explain</code>
it can be embedded both in the error message and as a specific <code>:code</code> (e.g.
<code>:malli/required</code>, <code>:malli/string</code>, <code>:malli/string-with-length-between</code>,
<code>:malli/string-with-length-max</code>, <code>:malli/string-with-length-min</code>). However, if
you don&rsquo;t care about that information (not even while debugging?) then you can
use the result from <code>humanize</code>. Just be aware that the result is not a simple
&ldquo;property -> vector-of-messages&rdquo; hash-map, but can be nested as indicated in the
example above.</p><p>You could even combine the results of <code>malli.core/explain</code> and
<code>malli.error/humanize</code> to collect all of the information from <code>explain</code>, but
also reuse the error messages from <code>humanize</code>. This could get rid of duplicated
templates between <code>error-template.edn</code> and <code>malli.error/default-errors</code>. Feel
free to consider if this is worthwhile for your project.</p><h2 id=what-to-do-with-the-errors>What to do with the errors?<a hidden class=anchor aria-hidden=true href=#what-to-do-with-the-errors>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>let </span>[errors (<span style=color:#a6e22e>malli-validator/validate</span> schema value)]
</span></span><span style=display:flex><span>  ,,,)
</span></span></code></pre></div><p>Now that we have the <code>errors</code>, what do we do with them? We are in the same
situation as before. Please see the <a href=../using-the-error-model#what-to-do-with-the-errors>previous
suggestion</a>.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://mbezjak.github.io>Well Organized Bits</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>