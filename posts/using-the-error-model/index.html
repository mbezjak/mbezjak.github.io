<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Using the Error Model | Well Organized Bits</title><meta name=keywords content><meta name=description content="Let&rsquo;s see how to use the error model we defined in part 2. The one that works well enough:
error is a hash map errors is a vector of error Before we get started:
As before, we&rsquo;ll concentrate on the functions that validate something. Given the error model above, we&rsquo;ll want every validation function to return errors. We&rsquo;ll build on top of the implementation and existing operations. The focus here won&rsquo;t be on the individual error - what goes in the hash map."><meta name=author content="Miro Bezjak"><link rel=canonical href=https://mbezjak.github.io/posts/using-the-error-model/><meta name=google-site-verification content="62Vyu3hWVePJQe8DUK8iM3Xn2VdjXAAagXEIxsL5To0"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://mbezjak.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mbezjak.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mbezjak.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mbezjak.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mbezjak.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Using the Error Model"><meta property="og:description" content="Let&rsquo;s see how to use the error model we defined in part 2. The one that works well enough:
error is a hash map errors is a vector of error Before we get started:
As before, we&rsquo;ll concentrate on the functions that validate something. Given the error model above, we&rsquo;ll want every validation function to return errors. We&rsquo;ll build on top of the implementation and existing operations. The focus here won&rsquo;t be on the individual error - what goes in the hash map."><meta property="og:type" content="article"><meta property="og:url" content="https://mbezjak.github.io/posts/using-the-error-model/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-01T23:05:14+01:00"><meta property="article:modified_time" content="2023-01-01T23:05:14+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Using the Error Model"><meta name=twitter:description content="Let&rsquo;s see how to use the error model we defined in part 2. The one that works well enough:
error is a hash map errors is a vector of error Before we get started:
As before, we&rsquo;ll concentrate on the functions that validate something. Given the error model above, we&rsquo;ll want every validation function to return errors. We&rsquo;ll build on top of the implementation and existing operations. The focus here won&rsquo;t be on the individual error - what goes in the hash map."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://mbezjak.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Using the Error Model","item":"https://mbezjak.github.io/posts/using-the-error-model/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Using the Error Model","name":"Using the Error Model","description":"Let\u0026rsquo;s see how to use the error model we defined in part 2. The one that works well enough:\nerror is a hash map errors is a vector of error Before we get started:\nAs before, we\u0026rsquo;ll concentrate on the functions that validate something. Given the error model above, we\u0026rsquo;ll want every validation function to return errors. We\u0026rsquo;ll build on top of the implementation and existing operations. The focus here won\u0026rsquo;t be on the individual error - what goes in the hash map.","keywords":[],"articleBody":"Let’s see how to use the error model we defined in part 2. The one that works well enough:\nerror is a hash map errors is a vector of error Before we get started:\nAs before, we’ll concentrate on the functions that validate something. Given the error model above, we’ll want every validation function to return errors. We’ll build on top of the implementation and existing operations. The focus here won’t be on the individual error - what goes in the hash map. The focus here will be on creating and combining multiple errors. Ready? Let’s go.\nCutting the boilerplate Let’s start simple and work our way up. A function that returns a single error.\n(defn validate [,,,] (errors/make [{:code :account/destination-not-found}])) defn, a function name, and arguments are an unneeded distraction so we’ll drop them from the following code snippets.\nReturning two or more errors is equally straightforward.\n(errors/make [{:code :account/destination-not-found} {:code :account/insufficient-amount}]) Shouldn’t all that be behind a conditional? Let’s try.\n(errors/make [(when-not dest-account {:code :account/destination-not-found}) (when (neg? remaining-amount) {:code :account/insufficient-amount})]) Hmm. That doesn’t look right. We might get [nil nil] as an argument to errors/make. nil doesn’t represent an error. According to the model, an error must be a hash map. So let’s take nil out. Let’s also return nil (vs. []) to indicate no errors.\n(-\u003e\u003e [(when-not dest-account {:code :account/destination-not-found}) (when (neg? remaining-amount) {:code :account/insufficient-amount})] (remove nil?) (errors/make) (not-empty)) Sometimes it’s nice to introduce new bindings close to the error vs. at the top of the function.\n(-\u003e\u003e [(when-not dest-account {:code :account/destination-not-found}) (when (neg? remaining-amount) {:code :account/insufficient-amount}) (when-let [invalid (invalid-characters transaction-description)] {:code :transaction/description-invalid-characters :args [invalid] :allowed (allowed-sepa-characters)})] (remove nil?) (errors/make) (not-empty)) However, what when a let needs to return multiple errors? Use flatten.\n(-\u003e\u003e [(when-not dest-account {:code :account/destination-not-found}) (when (neg? remaining-amount) {:code :account/insufficient-amount}) (when-let [invalid (invalid-characters transaction-description)] {:code :transaction/description-invalid-characters :args [invalid] :allowed (allowed-sepa-characters)}) (let [sepa-countries (sepa-participating-country-codes) can-be-local? (local-capable-transport? transaction) can-be-sepa? (contains? sepa-countries destination-country-code) must-be-swift? (and (not can-be-local?) (not can-be-sepa?)) user-chose-local? (user-chose-local-transport? transaction) user-chose-swift? (user-chose-swift-transport? transaction)] [(when (and can-be-local? (not user-chose-local?)) {:code :exchange/local-exchange-is-cheaper}) (when (and can-be-sepa? user-chose-swift?) {:code :exchange/sepa-exchange-is-cheaper}) (when (and can-be-sepa? user-chose-local?) {:code :exchange/must-use-sepa-transport}) (when (and must-be-swift? (not user-chose-swift?)) {:code :exchange/must-use-swift-transport})])] (flatten) (remove nil?) (errors/make) (not-empty)) This also works nicely with for.\n(-\u003e\u003e [(when-not (:source-account monthly-salaries) {:code :account/source-not-found}) (when (neg? remaining-amount) {:code :account/insufficient-amount}) (when (empty? (:transactions monthly-salaries)) {:code :monthly-salaries/empty}) (for [salary-transaction (:transactions monthly-salaries)] [(validate-transaction salary-transaction) (when (business-account? salary-transaction) {:code :monthly-salaries/contracting-work-should-be-separate})])] (flatten) (remove nil?) (errors/make) (not-empty)) What about when wanting to reuse existing functions?\n(-\u003e\u003e [(validate-source-account (:source-account transaction)) (validate-destination-account (:destination-account transaction)) (validate-currency (:currency transaction)) (validate-amount (:amount transaction) (:currency transaction)) (validate-description (:description transaction)) (validate-possible-fraud transaction) ,,,] (flatten) (remove nil?) (errors/make) (not-empty)) So far so good. There is some boilerplate that we need to write to ensure the consistency of the error model. However, that’s easy to get rid of. We just need a new function in errors.clj:\n(defn validate [\u0026 results] (-\u003e\u003e results (flatten) (remove nil?) (make) (not-empty))) Then the boilerplate is replaced with a single errors/validate call. This acts as s signal to the reader reading the code that the code is about to concatenate all the errors.\n(errors/validate (validate-source-account (:source-account transaction)) (validate-destination-account (:destination-account transaction)) (validate-currency (:currency transaction)) (validate-amount (:amount transaction) (:currency transaction)) (validate-description (:description transaction)) (validate-possible-fraud transaction) ,,,) Combining validations conditionally What gets hairy is conditionally running validation depending on if the previous function call returned errors or not. For example, something like this: 1\n(if-let [lexical-errors (lexical-analysis program-representation)] lexical-errors (if-let [syntactic-errors (syntax-analysis program-representation)] syntactic-errors (if-let [semantic-errors (semantic-analysis program-representation)] semantic-errors (errors/validate (validate-output-for-x86 program-representation) (validate-output-for-arm program-representation) (validate-output-for-risc-v program-representation) (validate-output-for-js program-representation))))) In my experience:\n“Don’t validate if previous validation failed” is surprisingly common. Groups of validations that run together can be arbitrary in size. Ideally, validations should have as little accidental complexity as possible. This means we need a little help to make the code a bit more readable and understandable. How about something like this?\n(errors/validate-groups (lexical-analysis program-representation) errors/continue-if-above-success (syntax-analysis program-representation) errors/continue-if-above-success (semantic-analysis program-representation) errors/continue-if-above-success (validate-output-for-x86 program-representation) (validate-output-for-arm program-representation) (validate-output-for-risc-v program-representation) (validate-output-for-js program-representation)) That’s a bit nicer. The reader can clearly see which errors are going to be concatenated together and what will be executed separately if the code above doesn’t yield errors. See the appendix for the implementation of this macro.\nFunctions that want to return more than just errors What about when we have a function that wants to return either a successful value (not simply nil) or errors? E.g. parse-int?\nHere is one way to handle them. Break the function into two parts:\na success-or-nil function 2 a validation function For example:\n(defn parse-int [text] (try (Integer/parseInt text) (catch NumberFormatException _ nil))) With a validation.\n(defn validate-int [text] (let [x (parse-int text)] (errors/validate (when-not x {:code :core/not-a-number :args [text]})))) Be aware that this does have drawbacks.\nparse-int will be called twice: once for the validation and once after all the validations succeeded to get the integer and do stuff with it. This has negative performance characteristics that you might not be ok with.\nThis technique works for simple cases but breaks down for more complex ones. E.g. call-external-services might not want to return nil because that means losing a lot of information needed for debugging and potentially error reporting. Information like request, response, exception, etc. In cases such as those, it’s better to seek alternative implementation or simply rethink how to implement call-external-service.\nAlternative implementations Depending on your project, errors/validate and errors/validate-groups can be good enough for most use cases. If not then here are two alternatives to consider: either and returning a pair. Feel free to consider your own alternatives. The goal should be to make it easy to deal with errors in your project.\nIf you have some experience with monads, you might already know that a biased either monad can model a return of a successful value or errors. I played around with the monads before, but so far I haven’t needed them in Clojure. However, for this particular use case, either monad might be worthwhile.\nHere is what that would look like.\n(defn parse-int [text] (try (either/success (Integer/parseInt text)) (catch NumberFormatException e (either/failure-1 {:code :core/not-a-number :args [text] :exception e})))) See the appendix below for the implementation of a biased either monad.\nMonads are used not by constantly peaking inside, but by using higher-order functions to let the monad handle what it was designed to do. E.g. this doesn’t work so nicely because both x and y are monads, not integers.\n(let [x (parse-int ,,,) y (parse-int ,,,)] (+ x y)) A sufficiently powerful macro can help here.\n(either/mlet [x (parse-int ,,,) y (parse-int ,,,)] (+ x y)) The problem with a monad is that it “infects” everything else. That is, once a monad is produced, the way to interact with it is to use either/mlet or either/map-success to produce another one. Every code dealing with a monad needs to do the same. All the way to the top. That doesn’t look so nice in Clojure. On the other hand, if your project has a very shallow call stack then there aren’t many places to consider. The trade-off might be worth it in your project.\nWhat about if you have a function that wants to return both errors and a (partial) success value? E.g. parse-amounts might want to return successfully parsed amounts as well as errors about the amounts that failed to parse. This is a case for a product type, not a sum type. You might want to create a new deftype. Or you can simply represent them as pairs in Clojure: [successful-value errors] 3.\nWhat to do with the errors? However you end up collecting errors, the final question remains: what to do with them once you have them? The code that generated them is rarely the best place to deal with them. Most of the time they have to be carried to the higher-up code for it to decide what to do with them. How to do that?\nIf you’ve collected as much as you can then at some point they will simply get in the way: 4\nyou have to pass errors along, and/or constantly check them with if or if using either then you constantly have to be using either/map-success, either/mlet, or similar What I saw works well in practice is to simply throw them as an exception (via ex-info). Yes, the boring Java throw. It’s a simple solution to the problem of letting 5 some higher-up code know that it has to deal with the produced errors. Perhaps it might also trigger a DB rollback which might be desirable.\nHere is what that might look like.\n(defn transfer-money [account-from account-to amount] (errors/throw! (validate ,,,)) (initiate-transfer ,,,)) Same for the previously mentioned call-external-service.\n(defn call-external-service [,,,] (let [request ,,, response (http-client/request request)] (when-not (expected-response? response) (errors/throw! (errors/make-1 {:code :external-service/failed :args [(:uri request)] :request request :response response}))) (:body response))) Who can then deal with those exceptions? In an HTTP service, a ring middleware can. We saw already what that might look like in part 2. Here is the same snippet, a bit expanded.\n(defn wrap-exception [handler] (fn [request] (try (handler request) (catch Exception ex (cond (errors/validation-exception? ex) (let [errors (-\u003e\u003e ex (errors/unwrap-exception) (errors/with-message (get-message-tpls)))] {:status (or (errors/suggested-http-code errors) 400) :body (-\u003eerrors-body errors)}) :else {:status 500 :body (exception-\u003eerrors-body ex)}))))) Appendix: Additions to errors.clj Refer to clojure.core extensions for some of the functions used here. For tests, please see the full gist: https://gist.github.com/mbezjak/1112a321d12c7aaf41a2d7140f2a535a\nAppendix: Biased either monad The code is not fully complete, but should be enough to get you started. For tests, please see the full gist: https://gist.github.com/mbezjak/193845228a71b826f58a95a9b2e7194e\nThis is of course a contrived example. In reality, a compiler doesn’t merely validate a program-representation but also takes the input and produces intermediate results such as AST. ↩︎\nClojure 1.11 added a couple of variants of success-or-nil functions. ↩︎\nShould it be [errors successful-value]? See the problem? Try to find a way not to confuse yourself or your fellow programmers. ↩︎\nPerhaps not. Perhaps returning them to where they are needed is the simplest (and most performant?) solution that works well enough in your project. You need to decide on the trade-offs. ↩︎\n“Don’t use exceptions for control flow” is an objection sometimes raised. Depending on what you consider exceptional it might be valid or not. However, exceptions are well understood on the JVM and might be the best no-additional-boilerplate GOTO statement that does the job correctly.\nThere is also the issue of performance. If inside of a tight loop then throwing an exception might not be the best solution. Don’t optimize too early, though. Verify if not throwing would give you much needed performance improvement.\nFinally, you might wonder why go through the pain of defining the error model if you end up throwing errors as exceptions anyway? The error model is here to have just one representation of errors, while the supporting functions are here to help you collect as many of them as possible. Throwing errors comes at a point when you cannot meaningfully deal with them in the code where you have them, but have to let some higher-up code know about them. ↩︎\n","wordCount":"1833","inLanguage":"en","datePublished":"2023-01-01T23:05:14+01:00","dateModified":"2023-01-01T23:05:14+01:00","author":{"@type":"Person","name":"Miro Bezjak"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mbezjak.github.io/posts/using-the-error-model/"},"publisher":{"@type":"Organization","name":"Well Organized Bits","logo":{"@type":"ImageObject","url":"https://mbezjak.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mbezjak.github.io accesskey=h title="Well Organized Bits (Alt + H)">Well Organized Bits</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mbezjak.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=mailto:well.organized.bits@proton.me title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mbezjak.github.io>Home</a>&nbsp;»&nbsp;<a href=https://mbezjak.github.io/posts/>Posts</a></div><h1 class=post-title>Using the Error Model</h1><div class=post-meta><span title='2023-01-01 23:05:14 +0100 +0100'>January 1, 2023</span>&nbsp;·&nbsp;Miro Bezjak&nbsp;|&nbsp;<a href=https://github.com/mbezjak/mbezjak.github.io/blob/main/content/posts/using-the-error-model.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Let&rsquo;s see how to use the <a href=../error-model>error model we defined in part 2</a>. The
one that works well enough:</p><ul><li><code>error</code> is a hash map</li><li><code>errors</code> is a vector of <code>error</code></li></ul><p>Before we get started:</p><ul><li>As before, we&rsquo;ll concentrate on the functions that <a href=../what-is-a-validation>validate
something</a>.</li><li>Given the error model above, we&rsquo;ll want every validation function to return
<code>errors</code>.</li><li>We&rsquo;ll build on top of the <a href=https://gist.github.com/mbezjak/c1baeece563b8ed734692938e6d1a36f>implementation and existing
operations</a>.</li><li>The focus here won&rsquo;t be on the individual error - what goes in the hash map.</li><li>The focus here will be on creating and combining multiple errors.</li></ul><p>Ready? Let&rsquo;s go.</p><h2 id=cutting-the-boilerplate>Cutting the boilerplate<a hidden class=anchor aria-hidden=true href=#cutting-the-boilerplate>#</a></h2><p>Let&rsquo;s start simple and work our way up. A function that returns a single error.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>validate [,,,]
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>errors/make</span>
</span></span><span style=display:flex><span>   [{<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/destination-not-found</span>}]))
</span></span></code></pre></div><p><code>defn</code>, a function name, and arguments are an unneeded distraction so we&rsquo;ll drop
them from the following code snippets.</p><p>Returning two or more errors is equally straightforward.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>errors/make</span>
</span></span><span style=display:flex><span> [{<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/destination-not-found</span>}
</span></span><span style=display:flex><span>  {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/insufficient-amount</span>}])
</span></span></code></pre></div><p>Shouldn&rsquo;t all that be behind a conditional? Let&rsquo;s try.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>errors/make</span>
</span></span><span style=display:flex><span> [(when-not dest-account {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/destination-not-found</span>})
</span></span><span style=display:flex><span>  (when (neg? remaining-amount) {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/insufficient-amount</span>})])
</span></span></code></pre></div><p>Hmm. That doesn&rsquo;t look right. We might get <code>[nil nil]</code> as an argument to
<code>errors/make</code>. <code>nil</code> doesn&rsquo;t represent an error. According to the model, an
error must be a hash map. So let&rsquo;s take <code>nil</code> out. Let&rsquo;s also return <code>nil</code> (vs.
<code>[]</code>) to indicate no errors.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>-&gt;&gt;</span> [(when-not dest-account {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/destination-not-found</span>})
</span></span><span style=display:flex><span>      (when (neg? remaining-amount) {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/insufficient-amount</span>})]
</span></span><span style=display:flex><span>     (remove nil?)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>errors/make</span>)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>not-empty</span>))
</span></span></code></pre></div><p>Sometimes it&rsquo;s nice to introduce new bindings close to the error vs. at the top
of the function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>-&gt;&gt;</span> [(when-not dest-account {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/destination-not-found</span>})
</span></span><span style=display:flex><span>      (when (neg? remaining-amount) {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/insufficient-amount</span>})
</span></span><span style=display:flex><span>      (when-let [invalid (<span style=color:#a6e22e>invalid-characters</span> transaction-description)]
</span></span><span style=display:flex><span>        {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:transaction/description-invalid-characters</span>
</span></span><span style=display:flex><span>         <span style=color:#e6db74>:args</span> [invalid]
</span></span><span style=display:flex><span>         <span style=color:#e6db74>:allowed</span> (<span style=color:#a6e22e>allowed-sepa-characters</span>)})]
</span></span><span style=display:flex><span>     (remove nil?)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>errors/make</span>)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>not-empty</span>))
</span></span></code></pre></div><p>However, what when a <code>let</code> needs to return multiple errors? Use <code>flatten</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>-&gt;&gt;</span> [(when-not dest-account {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/destination-not-found</span>})
</span></span><span style=display:flex><span>      (when (neg? remaining-amount) {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/insufficient-amount</span>})
</span></span><span style=display:flex><span>      (when-let [invalid (<span style=color:#a6e22e>invalid-characters</span> transaction-description)]
</span></span><span style=display:flex><span>        {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:transaction/description-invalid-characters</span>
</span></span><span style=display:flex><span>         <span style=color:#e6db74>:args</span> [invalid]
</span></span><span style=display:flex><span>         <span style=color:#e6db74>:allowed</span> (<span style=color:#a6e22e>allowed-sepa-characters</span>)})
</span></span><span style=display:flex><span>      (<span style=color:#66d9ef>let </span>[sepa-countries (<span style=color:#a6e22e>sepa-participating-country-codes</span>)
</span></span><span style=display:flex><span>            can-be-local? (<span style=color:#a6e22e>local-capable-transport?</span> transaction)
</span></span><span style=display:flex><span>            can-be-sepa? (contains? sepa-countries destination-country-code)
</span></span><span style=display:flex><span>            must-be-swift? (and (not can-be-local?) (not can-be-sepa?))
</span></span><span style=display:flex><span>            user-chose-local? (<span style=color:#a6e22e>user-chose-local-transport?</span> transaction)
</span></span><span style=display:flex><span>            user-chose-swift? (<span style=color:#a6e22e>user-chose-swift-transport?</span> transaction)]
</span></span><span style=display:flex><span>        [(when (and can-be-local? (not user-chose-local?))
</span></span><span style=display:flex><span>           {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:exchange/local-exchange-is-cheaper</span>})
</span></span><span style=display:flex><span>         (when (and can-be-sepa? user-chose-swift?)
</span></span><span style=display:flex><span>           {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:exchange/sepa-exchange-is-cheaper</span>})
</span></span><span style=display:flex><span>         (when (and can-be-sepa? user-chose-local?)
</span></span><span style=display:flex><span>           {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:exchange/must-use-sepa-transport</span>})
</span></span><span style=display:flex><span>         (when (and must-be-swift? (not user-chose-swift?))
</span></span><span style=display:flex><span>           {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:exchange/must-use-swift-transport</span>})])]
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>flatten</span>)
</span></span><span style=display:flex><span>     (remove nil?)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>errors/make</span>)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>not-empty</span>))
</span></span></code></pre></div><p>This also works nicely with <code>for</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>-&gt;&gt;</span> [(when-not (<span style=color:#e6db74>:source-account</span> monthly-salaries) {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/source-not-found</span>})
</span></span><span style=display:flex><span>      (when (neg? remaining-amount) {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:account/insufficient-amount</span>})
</span></span><span style=display:flex><span>      (when (<span style=color:#a6e22e>empty?</span> (<span style=color:#e6db74>:transactions</span> monthly-salaries)) {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:monthly-salaries/empty</span>})
</span></span><span style=display:flex><span>      (for [salary-transaction (<span style=color:#e6db74>:transactions</span> monthly-salaries)]
</span></span><span style=display:flex><span>        [(<span style=color:#a6e22e>validate-transaction</span> salary-transaction)
</span></span><span style=display:flex><span>         (when (<span style=color:#a6e22e>business-account?</span> salary-transaction)
</span></span><span style=display:flex><span>           {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:monthly-salaries/contracting-work-should-be-separate</span>})])]
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>flatten</span>)
</span></span><span style=display:flex><span>     (remove nil?)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>errors/make</span>)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>not-empty</span>))
</span></span></code></pre></div><p>What about when wanting to reuse existing functions?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>-&gt;&gt;</span> [(<span style=color:#a6e22e>validate-source-account</span> (<span style=color:#e6db74>:source-account</span> transaction))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>validate-destination-account</span> (<span style=color:#e6db74>:destination-account</span> transaction))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>validate-currency</span> (<span style=color:#e6db74>:currency</span> transaction))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>validate-amount</span> (<span style=color:#e6db74>:amount</span> transaction) (<span style=color:#e6db74>:currency</span> transaction))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>validate-description</span> (<span style=color:#e6db74>:description</span> transaction))
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>validate-possible-fraud</span> transaction)
</span></span><span style=display:flex><span>      ,,,]
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>flatten</span>)
</span></span><span style=display:flex><span>     (remove nil?)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>errors/make</span>)
</span></span><span style=display:flex><span>     (<span style=color:#a6e22e>not-empty</span>))
</span></span></code></pre></div><p>So far so good. There is some boilerplate that we need to write to ensure the
consistency of the error model. However, that&rsquo;s easy to get rid of. We just need
a new function in <code>errors.clj</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>validate [<span style=color:#f92672>&amp;</span> results]
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>-&gt;&gt;</span> results
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>flatten</span>)
</span></span><span style=display:flex><span>       (remove nil?)
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>make</span>)
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>not-empty</span>)))
</span></span></code></pre></div><p>Then the boilerplate is replaced with a single <code>errors/validate</code> call. This acts
as s signal to the reader reading the code that the code is about to concatenate
all the errors.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>errors/validate</span>
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>validate-source-account</span> (<span style=color:#e6db74>:source-account</span> transaction))
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>validate-destination-account</span> (<span style=color:#e6db74>:destination-account</span> transaction))
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>validate-currency</span> (<span style=color:#e6db74>:currency</span> transaction))
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>validate-amount</span> (<span style=color:#e6db74>:amount</span> transaction) (<span style=color:#e6db74>:currency</span> transaction))
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>validate-description</span> (<span style=color:#e6db74>:description</span> transaction))
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>validate-possible-fraud</span> transaction)
</span></span><span style=display:flex><span> ,,,)
</span></span></code></pre></div><h2 id=combining-validations-conditionally>Combining validations conditionally<a hidden class=anchor aria-hidden=true href=#combining-validations-conditionally>#</a></h2><p>What gets hairy is conditionally running validation depending on if the previous
function call returned errors or not. For example, something like this: <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(if-let [lexical-errors (<span style=color:#a6e22e>lexical-analysis</span> program-representation)]
</span></span><span style=display:flex><span>  lexical-errors
</span></span><span style=display:flex><span>  (if-let [syntactic-errors (<span style=color:#a6e22e>syntax-analysis</span> program-representation)]
</span></span><span style=display:flex><span>    syntactic-errors
</span></span><span style=display:flex><span>    (if-let [semantic-errors (<span style=color:#a6e22e>semantic-analysis</span> program-representation)]
</span></span><span style=display:flex><span>      semantic-errors
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>errors/validate</span>
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>validate-output-for-x86</span> program-representation)
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>validate-output-for-arm</span> program-representation)
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>validate-output-for-risc-v</span> program-representation)
</span></span><span style=display:flex><span>       (<span style=color:#a6e22e>validate-output-for-js</span> program-representation)))))
</span></span></code></pre></div><p>In my experience:</p><ul><li>&ldquo;Don&rsquo;t validate if previous validation failed&rdquo; is surprisingly common.</li><li>Groups of validations that run together can be arbitrary in size.</li><li>Ideally, validations should have as little <a href=https://github.com/papers-we-love/papers-we-love/blob/master/design/out-of-the-tar-pit.pdf>accidental
complexity</a>
as possible.</li></ul><p>This means we need a little help to make the code a bit more readable and
understandable. How about something like this?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>errors/validate-groups</span>
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>lexical-analysis</span> program-representation)
</span></span><span style=display:flex><span> errors/continue-if-above-success
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>syntax-analysis</span> program-representation)
</span></span><span style=display:flex><span> errors/continue-if-above-success
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>semantic-analysis</span> program-representation)
</span></span><span style=display:flex><span> errors/continue-if-above-success
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>validate-output-for-x86</span> program-representation)
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>validate-output-for-arm</span> program-representation)
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>validate-output-for-risc-v</span> program-representation)
</span></span><span style=display:flex><span> (<span style=color:#a6e22e>validate-output-for-js</span> program-representation))
</span></span></code></pre></div><p>That&rsquo;s a bit nicer. The reader can clearly see which errors are going to be
concatenated together and what will be executed separately if the code above
doesn&rsquo;t yield errors. See the appendix for the implementation of this macro.</p><h2 id=functions-that-want-to-return-more-than-just-errors>Functions that want to return more than just errors<a hidden class=anchor aria-hidden=true href=#functions-that-want-to-return-more-than-just-errors>#</a></h2><p>What about when we have a function that wants to return either a successful
value (not simply <code>nil</code>) or <code>errors</code>? E.g. <code>parse-int</code>?</p><p>Here is one way to handle them. Break the function into two parts:</p><ul><li>a success-or-nil function <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></li><li>a validation function</li></ul><p>For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>parse-int [text]
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>try</span>
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>Integer/parseInt</span> text)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>catch</span> NumberFormatException _
</span></span><span style=display:flex><span>      nil)))
</span></span></code></pre></div><p>With a validation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>validate-int [text]
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>[x (<span style=color:#a6e22e>parse-int</span> text)]
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>errors/validate</span>
</span></span><span style=display:flex><span>     (when-not x
</span></span><span style=display:flex><span>       {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:core/not-a-number</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>:args</span> [text]}))))
</span></span></code></pre></div><p>Be aware that this does have drawbacks.</p><p><code>parse-int</code> will be called twice: once for the validation and once after all the
validations succeeded to get the integer and do stuff with it. This has negative
performance characteristics that you might not be ok with.</p><p>This technique works for simple cases but breaks down for more complex ones.
E.g. <code>call-external-services</code> might not want to return <code>nil</code> because that means
losing a lot of information needed for debugging and potentially error
reporting. Information like <code>request</code>, <code>response</code>, exception, etc. In cases such
as those, it&rsquo;s better to seek <a href=#alternative-implementations>alternative
implementation</a> or simply <a href=#what-to-do-with-the-errors>rethink how to
implement</a> <code>call-external-service</code>.</p><h2 id=alternative-implementations>Alternative implementations<a hidden class=anchor aria-hidden=true href=#alternative-implementations>#</a></h2><p>Depending on your project, <code>errors/validate</code> and <code>errors/validate-groups</code> can be
good enough for most use cases. If not then here are two alternatives to
consider: either and returning a pair. Feel free to consider your own
alternatives. The goal should be to make it easy to deal with errors in your
project.</p><p>If you have <a href=http://learnyouahaskell.com>some</a>
<a href=https://wiki.haskell.org/Typeclassopedia>experience</a>
<a href=https://scalaz.github.io/7/>with</a> <a href=https://github.com/funcool/cats>monads</a>,
you might already know that a biased either monad can model a return of a
successful value or <code>errors</code>. I
<a href=https://github.com/mbezjak/playground/tree/572f8f424189dc6358326412ad5cfe678b24bffe/clojure/cats>played</a>
around with the monads before, but so far I haven&rsquo;t needed them in Clojure.
However, for this particular use case, either monad might be worthwhile.</p><p>Here is what that would look like.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>parse-int [text]
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>try</span>
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>either/success</span> (<span style=color:#a6e22e>Integer/parseInt</span> text))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>catch</span> NumberFormatException e
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>either/failure-1</span> {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:core/not-a-number</span>
</span></span><span style=display:flex><span>                         <span style=color:#e6db74>:args</span> [text]
</span></span><span style=display:flex><span>                         <span style=color:#e6db74>:exception</span> e}))))
</span></span></code></pre></div><p>See the appendix below for the implementation of a biased either monad.</p><p>Monads are used not by constantly peaking inside, but by using higher-order
functions to let the monad handle what it was designed to do. E.g. this doesn&rsquo;t
work so nicely because both <code>x</code> and <code>y</code> are monads, not integers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>let </span>[x (<span style=color:#a6e22e>parse-int</span> ,,,)
</span></span><span style=display:flex><span>      y (<span style=color:#a6e22e>parse-int</span> ,,,)]
</span></span><span style=display:flex><span>  (+ x y))
</span></span></code></pre></div><p>A sufficiently powerful macro can help here.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#a6e22e>either/mlet</span> [x (<span style=color:#a6e22e>parse-int</span> ,,,)
</span></span><span style=display:flex><span>              y (<span style=color:#a6e22e>parse-int</span> ,,,)]
</span></span><span style=display:flex><span>  (+ x y))
</span></span></code></pre></div><p>The problem with a monad is that it &ldquo;infects&rdquo; everything else. That is, once a
monad is produced, the way to interact with it is to use <code>either/mlet</code> or
<code>either/map-success</code> to produce another one. Every code dealing with a monad
needs to do the same. All the way to the top. That doesn&rsquo;t look so nice in
Clojure. On the other hand, if your project has a very shallow call stack then
there aren&rsquo;t many places to consider. The trade-off might be worth it in your
project.</p><p>What about if you have a function that wants to return both <code>errors</code> and a
(partial) success value? E.g. <code>parse-amounts</code> might want to return successfully
parsed amounts as well as <code>errors</code> about the amounts that failed to parse. This
is a case for a product type, not a sum type. You might want to create a new
<code>deftype</code>. Or you can simply represent them as pairs in Clojure:
<code>[successful-value errors]</code> <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><h2 id=what-to-do-with-the-errors>What to do with the errors?<a hidden class=anchor aria-hidden=true href=#what-to-do-with-the-errors>#</a></h2><p>However you end up collecting errors, the final question remains: what to do
with them once you have them? The code that generated them is rarely the best
place to deal with them. Most of the time they have to be carried to the
higher-up code for it to decide what to do with them. How to do that?</p><p>If you&rsquo;ve collected as much as you can then at some point they will simply get
in the way: <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></p><ul><li>you have to pass <code>errors</code> along, and/or constantly check them with <code>if</code></li><li>or if using <code>either</code> then you constantly have to be using
<code>either/map-success</code>, <code>either/mlet</code>, or similar</li></ul><p>What I saw works well in practice is to simply throw them as an exception (via
<code>ex-info</code>). Yes, the boring Java <code>throw</code>. It&rsquo;s a simple solution to the problem
of letting <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> some higher-up code know that it has to deal with the produced
errors. Perhaps it might also trigger a DB rollback which might be desirable.</p><p>Here is what that might look like.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>transfer-money [account-from account-to amount]
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>errors/throw!</span> (<span style=color:#a6e22e>validate</span> ,,,))
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>initiate-transfer</span> ,,,))
</span></span></code></pre></div><p>Same for the previously mentioned<code> call-external-service</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>call-external-service [,,,]
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>[request ,,,
</span></span><span style=display:flex><span>        response (<span style=color:#a6e22e>http-client/request</span> request)]
</span></span><span style=display:flex><span>    (when-not (<span style=color:#a6e22e>expected-response?</span> response)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>errors/throw!</span> (<span style=color:#a6e22e>errors/make-1</span> {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:external-service/failed</span>
</span></span><span style=display:flex><span>                                     <span style=color:#e6db74>:args</span> [(<span style=color:#e6db74>:uri</span> request)]
</span></span><span style=display:flex><span>                                     <span style=color:#e6db74>:request</span> request
</span></span><span style=display:flex><span>                                     <span style=color:#e6db74>:response</span> response})))
</span></span><span style=display:flex><span>    (<span style=color:#e6db74>:body</span> response)))
</span></span></code></pre></div><p>Who can then deal with those exceptions? In an HTTP service, a ring middleware
can. We saw already what that might look like in <a href=../error-model#appendix>part
2</a>. Here is the same snippet, a bit expanded.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>wrap-exception [handler]
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>fn </span>[request]
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>try</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>handler</span> request)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>catch</span> Exception ex
</span></span><span style=display:flex><span>        (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>          (<span style=color:#a6e22e>errors/validation-exception?</span> ex)
</span></span><span style=display:flex><span>          (<span style=color:#66d9ef>let </span>[errors (<span style=color:#a6e22e>-&gt;&gt;</span> ex (<span style=color:#a6e22e>errors/unwrap-exception</span>) (<span style=color:#a6e22e>errors/with-message</span> (<span style=color:#a6e22e>get-message-tpls</span>)))]
</span></span><span style=display:flex><span>            {<span style=color:#e6db74>:status</span> (or (<span style=color:#a6e22e>errors/suggested-http-code</span> errors) <span style=color:#ae81ff>400</span>)
</span></span><span style=display:flex><span>             <span style=color:#e6db74>:body</span> (<span style=color:#a6e22e>-&gt;errors-body</span> errors)})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>          <span style=color:#e6db74>:else</span>
</span></span><span style=display:flex><span>          {<span style=color:#e6db74>:status</span> <span style=color:#ae81ff>500</span>
</span></span><span style=display:flex><span>           <span style=color:#e6db74>:body</span> (<span style=color:#a6e22e>exception-&gt;errors-body</span> ex)})))))
</span></span></code></pre></div><h2 id=appendix-additions-to-errorsclj>Appendix: Additions to errors.clj<a hidden class=anchor aria-hidden=true href=#appendix-additions-to-errorsclj>#</a></h2><p>Refer to <a href=../clojure-core-extensions>clojure.core extensions</a> for some of the
functions used here. For tests, please see the full gist:
<a href=https://gist.github.com/mbezjak/1112a321d12c7aaf41a2d7140f2a535a>https://gist.github.com/mbezjak/1112a321d12c7aaf41a2d7140f2a535a</a></p><script type=application/javascript src="https://gist.github.com/mbezjak/1112a321d12c7aaf41a2d7140f2a535a.js?file=errors.clj"></script><h2 id=appendix-biased-either-monad>Appendix: Biased either monad<a hidden class=anchor aria-hidden=true href=#appendix-biased-either-monad>#</a></h2><p>The code is not fully complete, but should be enough to get you started. For
tests, please see the full gist:
<a href=https://gist.github.com/mbezjak/193845228a71b826f58a95a9b2e7194e>https://gist.github.com/mbezjak/193845228a71b826f58a95a9b2e7194e</a></p><script type=application/javascript src="https://gist.github.com/mbezjak/193845228a71b826f58a95a9b2e7194e.js?file=either.clj"></script><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This is of course a contrived example. In reality, a compiler doesn&rsquo;t
merely validate a <code>program-representation</code> but also takes the input and
produces intermediate results such as AST.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://clojure.org/news/2022/03/22/clojure-1-11-0>Clojure 1.11</a> added a
couple of variants of success-or-nil functions.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Should it be <code>[errors successful-value]</code>? See the problem? Try to find a
way not to confuse yourself or your fellow programmers.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Perhaps not. Perhaps returning them to where they are needed is the
simplest (and most performant?) solution that works well enough in your
project. You need to decide on the trade-offs.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>&ldquo;Don&rsquo;t use exceptions for control flow&rdquo; is an objection sometimes raised.
Depending on what you consider <em>exceptional</em> it might be valid or not.
However, exceptions are well understood on the JVM and might be the best
no-additional-boilerplate GOTO statement that does the job correctly.</p><p>There is also the issue of performance. If inside of a tight loop then
throwing an exception might not be the best solution. Don&rsquo;t optimize too
early, though. Verify if not throwing would give you much needed performance
improvement.</p><p>Finally, you might wonder why go through the pain of defining the error
model if you end up throwing errors as exceptions anyway? The error model is
here to have just one representation of errors, while the supporting
functions are here to help you collect as many of them as possible. Throwing
errors comes at a point when you cannot meaningfully deal with them in the
code where you have them, but have to let some higher-up code know about
them.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://mbezjak.github.io>Well Organized Bits</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>