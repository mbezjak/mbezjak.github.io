<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Make Mulog Play Nice With Kaocha | Well Organized Bits</title><meta name=keywords content><meta name=description content="mulog is an excellent logging library for Clojure. It uses agents to process events asynchronously. This makes sense for deployed services.
But what about executing (integration, functional, etc.) tests? Some tests runners (e.g. Kaocha) try to capture the test output while the test is executing and provide that output in case the test failed. Do those two libraries play well together? Not really. The output captured cannot be relied upon:"><meta name=author content="Miro Bezjak"><link rel=canonical href=https://mbezjak.github.io/posts/make-mulog-play-nice-with-kaocha/><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://mbezjak.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mbezjak.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mbezjak.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mbezjak.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mbezjak.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Make Mulog Play Nice With Kaocha"><meta property="og:description" content="mulog is an excellent logging library for Clojure. It uses agents to process events asynchronously. This makes sense for deployed services.
But what about executing (integration, functional, etc.) tests? Some tests runners (e.g. Kaocha) try to capture the test output while the test is executing and provide that output in case the test failed. Do those two libraries play well together? Not really. The output captured cannot be relied upon:"><meta property="og:type" content="article"><meta property="og:url" content="https://mbezjak.github.io/posts/make-mulog-play-nice-with-kaocha/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-04T17:16:10+01:00"><meta property="article:modified_time" content="2022-11-04T17:16:10+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Make Mulog Play Nice With Kaocha"><meta name=twitter:description content="mulog is an excellent logging library for Clojure. It uses agents to process events asynchronously. This makes sense for deployed services.
But what about executing (integration, functional, etc.) tests? Some tests runners (e.g. Kaocha) try to capture the test output while the test is executing and provide that output in case the test failed. Do those two libraries play well together? Not really. The output captured cannot be relied upon:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://mbezjak.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Make Mulog Play Nice With Kaocha","item":"https://mbezjak.github.io/posts/make-mulog-play-nice-with-kaocha/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Make Mulog Play Nice With Kaocha","name":"Make Mulog Play Nice With Kaocha","description":"mulog is an excellent logging library for Clojure. It uses agents to process events asynchronously. This makes sense for deployed services.\nBut what about executing (integration, functional, etc.) tests? Some tests runners (e.g. Kaocha) try to capture the test output while the test is executing and provide that output in case the test failed. Do those two libraries play well together? Not really. The output captured cannot be relied upon:","keywords":[],"articleBody":"mulog is an excellent logging library for Clojure. It uses agents to process events asynchronously. This makes sense for deployed services.\nBut what about executing (integration, functional, etc.) tests? Some tests runners (e.g. Kaocha) try to capture the test output while the test is executing and provide that output in case the test failed. Do those two libraries play well together? Not really. The output captured cannot be relied upon:\neither the test output was not captured during the test execution at all (due to publish delay) or the output of previous test (or several of them) was captured Not really what we want when we’re trying to understand why the test failed. Worse still, there doesn’t seem to be any configuration option to improve the situation. And the test code that mulog itself uses doesn’t seem to be in a good direction for most projects because it makes all the tests wait for the next publish delay to be sure the events were processed.\nLuckily not all is lost. We can use Clojure’s late binding to change mulog. After a bit of looking around in mulog’s source code and a dash of thinking, this is what I came to use. It works reliably and I didn’t have any problems with it so far.\nmulog_init.clj\n(ns mulog-init (:require [com.brunobonacci.mulog.buffer :as buffer] [com.brunobonacci.mulog.core :as mulog-core] [com.brunobonacci.mulog.publisher :as publisher])) (defn make-mulog-sychronous [] ;; What? ;; Mulog handles events in asynchronous nature. This makes sense. Event ;; processing and send off is done in another thread so that the main thread ;; is not blocked. This code makes mulog handles events synchronously. ;; ;; Why? ;; Test runners (e.g. kaocha) capture test output while the test is running. ;; Capturing doesn't work at all if the event processing is asynchronous. What ;; usually happens is that: ;; - test B captures output from previously executed test A ;; - and/or output is completely lost ;; To have correct output capture, the event processing must be synchronous. ;; ;; How? ;; The hack below is exploiting the fact that all `mulog/log` calls go through ;; `mulog-core/enqueue!`. From there the event processing is roughly (from ;; reading of the source code): ;; 1. added to an atom (for performance reasons) ;; 2. (in a new thread) picked up events from an atom and send to each ;; publisher's agent-buffer ;; 3. (possibly in yet another thread) picked up events from agent-buffer and ;; process them by executing each publisher independently ;; The hack is consisting of hijacking 1. and and immediately giving the event ;; to each publisher. ;; ;; Note! ;; Because this is a hack, the implementation needs to be checked each time ;; mulog dependency gets updated. (let [f (fn [_ value] ;; we are even using a private function in `mulog-core` (let [event (apply @#'mulog-core/merge-pairs value)] (doseq [publisher (map :publisher (map second @mulog-core/publishers))] (publisher/publish publisher (buffer/enqueue (buffer/ring-buffer 1) event)))))] (alter-var-root #'mulog-core/enqueue! (constantly f)))) The code above can be used as part of system startup in Kaocha hooks.\n","wordCount":"506","inLanguage":"en","datePublished":"2022-11-04T17:16:10+01:00","dateModified":"2022-11-04T17:16:10+01:00","author":{"@type":"Person","name":"Miro Bezjak"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mbezjak.github.io/posts/make-mulog-play-nice-with-kaocha/"},"publisher":{"@type":"Organization","name":"Well Organized Bits","logo":{"@type":"ImageObject","url":"https://mbezjak.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mbezjak.github.io accesskey=h title="Well Organized Bits (Alt + H)">Well Organized Bits</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mbezjak.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=mailto:well.organized.bits@proton.me title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mbezjak.github.io>Home</a>&nbsp;»&nbsp;<a href=https://mbezjak.github.io/posts/>Posts</a></div><h1 class=post-title>Make Mulog Play Nice With Kaocha</h1><div class=post-meta><span title='2022-11-04 17:16:10 +0100 +0100'>November 4, 2022</span>&nbsp;·&nbsp;Miro Bezjak&nbsp;|&nbsp;<a href=https://github.com/mbezjak/mbezjak.github.io/blob/main/content/posts/make-mulog-play-nice-with-kaocha.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p><a href=https://github.com/BrunoBonacci/mulog>mulog</a> is an excellent logging library
for Clojure. It uses agents to process events asynchronously. This makes sense
for deployed services.</p><p>But what about executing (integration, functional, etc.) tests? Some tests
runners (e.g. <a href=https://github.com/lambdaisland/kaocha>Kaocha</a>) try to capture
the test output while the test is executing and provide that output in case the
test failed. Do those two libraries play well together? Not really. The output
captured cannot be relied upon:</p><ul><li>either the test output was not captured during the test execution at all (due
to publish delay)</li><li>or the output of previous test (or several of them) was captured</li></ul><p>Not really what we want when we&rsquo;re trying to understand why the test failed.
Worse still, there doesn&rsquo;t seem to be any configuration option to improve the
situation. And the <a href=https://github.com/BrunoBonacci/mulog/blob/0.9.0/mulog-core/test/com/brunobonacci/mulog/test_publisher.clj#L65>test
code</a>
that mulog itself uses doesn&rsquo;t seem to be in a good direction for most projects
because it makes all the tests wait for the next publish delay to be sure the
events were processed.</p><p>Luckily not all is lost. We can use Clojure&rsquo;s late binding to change mulog.
After a bit of looking around in mulog&rsquo;s source code and a dash of thinking,
this is what I came to use. It works reliably and I didn&rsquo;t have any problems
with it so far.</p><p><code>mulog_init.clj</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>ns </span>mulog-init
</span></span><span style=display:flex><span>  (<span style=color:#e6db74>:require</span>
</span></span><span style=display:flex><span>   [com.brunobonacci.mulog.buffer <span style=color:#e6db74>:as</span> buffer]
</span></span><span style=display:flex><span>   [com.brunobonacci.mulog.core <span style=color:#e6db74>:as</span> mulog-core]
</span></span><span style=display:flex><span>   [com.brunobonacci.mulog.publisher <span style=color:#e6db74>:as</span> publisher]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>make-mulog-sychronous []
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; What?</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; Mulog handles events in asynchronous nature. This makes sense. Event</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; processing and send off is done in another thread so that the main thread</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; is not blocked. This code makes mulog handles events synchronously.</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; Why?</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; Test runners (e.g. kaocha) capture test output while the test is running.</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; Capturing doesn&#39;t work at all if the event processing is asynchronous. What</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; usually happens is that:</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; - test B captures output from previously executed test A</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; - and/or output is completely lost</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; To have correct output capture, the event processing must be synchronous.</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; How?</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; The hack below is exploiting the fact that all `mulog/log` calls go through</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; `mulog-core/enqueue!`. From there the event processing is roughly (from</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; reading of the source code):</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; 1. added to an atom (for performance reasons)</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; 2. (in a new thread) picked up events from an atom and send to each</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;;    publisher&#39;s agent-buffer</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; 3. (possibly in yet another thread) picked up events from agent-buffer and</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;;    process them by executing each publisher independently</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; The hack is consisting of hijacking 1. and and immediately giving the event</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; to each publisher.</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;;</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; Note!</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; Because this is a hack, the implementation needs to be checked each time</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; mulog dependency gets updated.</span>
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>[f (<span style=color:#66d9ef>fn </span>[_ value]
</span></span><span style=display:flex><span>            <span style=color:#75715e>;; we are even using a private function in `mulog-core`</span>
</span></span><span style=display:flex><span>            (<span style=color:#66d9ef>let </span>[event (apply <span style=color:#f92672>@#</span><span style=color:#e6db74>&#39;mulog-core/merge-pairs</span> value)]
</span></span><span style=display:flex><span>              (doseq [publisher (map <span style=color:#e6db74>:publisher</span> (map second <span style=color:#f92672>@</span>mulog-core/publishers))]
</span></span><span style=display:flex><span>                (<span style=color:#a6e22e>publisher/publish</span> publisher (<span style=color:#a6e22e>buffer/enqueue</span> (<span style=color:#a6e22e>buffer/ring-buffer</span> <span style=color:#ae81ff>1</span>) event)))))]
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>alter-var-root</span> <span style=color:#f92672>#</span><span style=color:#e6db74>&#39;mulog-core/enqueue!</span> (constantly f))))
</span></span></code></pre></div><p>The code above can be used as part of system startup in <a href=../make-mulog-play-nice-with-kaocha>Kaocha
hooks</a>.</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://mbezjak.github.io>Well Organized Bits</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>