<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Error Model | Well Organized Bits</title><meta name=keywords content><meta name=description content="In part 1 we talked about the various tasks that can result in an error. Libraries can help with those tasks. However, there is still a whole bunch that the project will have to take care of. Let&rsquo;s continue from there. Here we&rsquo;ll concentrate on the error model - the way the errors are represented. What is that about?
Each library pulled in to help with the validation tasks represents errors in its own way."><meta name=author content="Miro Bezjak"><link rel=canonical href=https://mbezjak.github.io/posts/error-model/><meta name=google-site-verification content="62Vyu3hWVePJQe8DUK8iM3Xn2VdjXAAagXEIxsL5To0"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://mbezjak.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mbezjak.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mbezjak.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mbezjak.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mbezjak.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Error Model"><meta property="og:description" content="In part 1 we talked about the various tasks that can result in an error. Libraries can help with those tasks. However, there is still a whole bunch that the project will have to take care of. Let&rsquo;s continue from there. Here we&rsquo;ll concentrate on the error model - the way the errors are represented. What is that about?
Each library pulled in to help with the validation tasks represents errors in its own way."><meta property="og:type" content="article"><meta property="og:url" content="https://mbezjak.github.io/posts/error-model/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-10T15:25:38+01:00"><meta property="article:modified_time" content="2022-12-10T15:25:38+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Error Model"><meta name=twitter:description content="In part 1 we talked about the various tasks that can result in an error. Libraries can help with those tasks. However, there is still a whole bunch that the project will have to take care of. Let&rsquo;s continue from there. Here we&rsquo;ll concentrate on the error model - the way the errors are represented. What is that about?
Each library pulled in to help with the validation tasks represents errors in its own way."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://mbezjak.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Error Model","item":"https://mbezjak.github.io/posts/error-model/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Error Model","name":"Error Model","description":"In part 1 we talked about the various tasks that can result in an error. Libraries can help with those tasks. However, there is still a whole bunch that the project will have to take care of. Let\u0026rsquo;s continue from there. Here we\u0026rsquo;ll concentrate on the error model - the way the errors are represented. What is that about?\nEach library pulled in to help with the validation tasks represents errors in its own way.","keywords":[],"articleBody":"In part 1 we talked about the various tasks that can result in an error. Libraries can help with those tasks. However, there is still a whole bunch that the project will have to take care of. Let’s continue from there. Here we’ll concentrate on the error model - the way the errors are represented. What is that about?\nEach library pulled in to help with the validation tasks represents errors in its own way. The code you write in the project has even more ways to do the same. Let’s see a couple of examples of what that might look like.\nA function might throw a Java exception (e.g. java.lang.IllegalArgumentException) thus representing an error as a string message. A function might throw an clojure.lang.ExceptionInfo (via ex-info) thus representing an error as a string + hash map (via ex-data). A function might return true/false to indicate an error. A function might return an error message. A function might return a collection of error messages. malli.core/explain returns a hash map with :errors being a list of hash maps. malli.error/humanize returns a hash map of path -\u003e vector of messages. clojure.spec.alpha/explain-data returns a hash map with :problems being a vector of hash maps. buddy.sign.jwt/unsign throws ex-info with ex-data having :cause. 1 Calling an external service might return zero, one or many errors when it didn’t succeed, but in what format? JSON (or something similar) might be preferable, but the service might respond in HTML as well. A function might return a pair [error result] with error being anything from above. etc. Having to deal with a large subset of the above makes working on the project unnecessarily hard. It’s even harder when needing to collect multiple errors from multiple sources all using their own error model.\nWhat would make it easy is to have just one error model used throughout the project. Preferably the one that best suits your project and that you can control to make sure it will work best in the future as well. That seems easy enough in Clojure. Just define your own error model and base everything on top of it, wrapping libraries and external services if necessary.\nIn search of a model Pick a model that is generic enough to be able to represent any error your project produces and can represent errors from the libraries you’re using while still not being so involved that it makes it cumbersome to use.\nHow might we represent an error?\nLet’s start simple. An error message as a string.\n(defn validate [country] (when-not (country-exists? country) (format \"Country with code '%s' doesn't exist\" country))) A bit too simplistic? What if we want to attach country with the error? So, perhaps a hash map?\n(defn validate [country] (when-not (country-exists? country) {:message (format \"Country '%s' doesn't exist\" country) :country country})) A bit better, but what if we want to represent multiple errors, not just one? Perhaps a collection of hash maps?\n(defn validate [country] (let [errors [(when-not (headquarters-in? country) {:message (format \"I'm sorry, we don't have company headquarters in %s\" country) :headquarters (available-headquarters)}) (when (embargoed? country) {:message (format \"Sorry, by law we aren't allowed to conduct business in %s\" country) :country country}) (when (too-far-away? country) {:message \"You are too far away from us\" :supported-time-zones (supported-time-zones)})]] (remove nil? errors))) What about grouping errors together? Sure, if you need it. Continue on your own from here. Just remember not to overcomplicate the model. You’ll have to work with it regularly.\nA few notes to keep in mind:\nThis post is about defining the model within your programming language. Clojure is used here, but the same idea can be applied elsewhere. It’s not really about the HTTP response body. Although an identical model can be used for responses as well. Depending on the situation, the error hash map might be trimmed down to only the essentials (e.g. for public endpoints) or only slightly trimmed (e.g. for internal service-to-service communication). It’s not really about the database model. It’s mostly about the in-memory error model. Although, nothing is stopping you from saving errors to the DB if you have that requirement. When you decide on an error model, it can be used with exception throwing (ex-info) if you don’t want to simply return errors. Model that works well enough Here is one possible model that worked quite well for me for years.\nThe model:\nerror is a hash map errors is a vector of error That’s it. It’s simple, quite readable, and very extensible. The project recognizes a couple of known error keys such as :message, :code, :args, etc. However, at any point, for any reason, it allows the code to attach other keys to carry additional information. Presumably with the intent that some upstream code will use it. How exactly is up to you and the project you’re working on:\nrespond with it to an HTTP request handle it in an exception middleware (ring) save it to the DB add it to the queue log the event to ElasticSearch collect as metric etc. Here are the project-wide keys that are used most often.\nmessage {:message \"Country with code 'XA' doesn't exist\"} This is the simplest variant that’s the easiest to understand. It simply encodes an error message indented for a human. That doesn’t necessarily mean a customer. Perhaps you’re the one that’s going to be reading it from logs. Or perhaps it’s indented for another person within your organization.\nI don’t use it much. I find :code and :args much more advantageous.\ncode and args Instead of embedding the error message directly, we can let some other code deal with constructing the message, but at the point of creating an error, we simply want to refer to the eventual message. It looks like this:\n{:code :country/not-found :args [country-code2]} Where country-code2 is probably in a let binding. This has a couple of advantages:\nIt facilitates service-to-service communication. If service A calls B and B responds with errors, it’s easier to deal with the error code rather than a message intended for a human. Perhaps A needs to execute a different code path depending on if B responds with a specific error code. Information is easier to deal with than fishing out the relevant part with re-find.\nYou can let error messages live in an externalized EDN file (or Java properties, etc.). That way, all error messages for the project are in one place instead of being spread all over the code base. It also frees the code base from needing to concatenate strings together. Instead, a ring middleware might simply execute (apply format template args) once it reads the message template. An example EDN file is just a hash map from the error code to the error template.\nresources/error-templates.edn\n{:country/not-found \"Country with code '%s' doesn't exist\" :transaction/insufficient-funds \"Not enough funds in the bank account (%s) for money transfer. Available amount: %s. Needed amount: %s\"} It aids in translating error messages into other natural languages (German, Spanish, etc.). The solution might be similar to error-templates.edn or it could be much more involved. It depends on your project and what you need to solve. What’s important is for the error to carry the information until some code higher up can decide what to do with it. Perhaps it needs Accept-Language from HTTP headers?\nbreadcrumbs Path to the source that caused the error. For example, for a deeply nested structure that might be:\n{:code :malli/required :breadcrumbs [:customer :address :country :code]} suggested-http-code How to influence the HTTP response status code? Most of the time the default would be your favorite HTTP status code when an error occurs. What are you using: 400, 409, 412, 422? Sometimes, however, you want to explicitly define the status code. For example:\n{:code :jwt/expired :suggested-http-code 401} Theoretically this can be ambiguous if errors are:\n[{:code :jwt/expired :suggested-http-code 401} {:code :produt/not-found :suggested-http-code 404}] However, I haven’t seen that ambiguity in practice. Mostly because the example above doesn’t make sense. If authentication fails then the middleware responds to an HTTP request immediately instead of executing more code. Same with other errors that want to suggest an HTTP code.\nOther ideas Here are some more ideas for you to think about and maybe try.\nAdd :severity to describe how important is this error. Values might be :fatal, :warning, :note, … Add :module and make error messages like “Amount is required” a bit less ambiguous. What module produced this error? Was it: transaction, cart, order, warehouse, …? Most of the time, I let exceptions flow all the way to the ring exception middleware because it has the most information on how to react. Sometimes, however, it’s nice to be able to catch it and return it as an error. Perhaps you want to attach the cause as :exception? Add :response if service A called service B and B failed to do its job properly. Your REPL experience will be much nicer if you can see and interact with that information instead of just throwing it away. If any error occurs you’ll likely want to trigger a DB rollback. Sometimes you might not want to do this. Add :transaction-rollback? false to indicate it to the higher-up code. Add :contact-support? true to let UI know and present a special screen to the customer. The error is such that the customer can do nothing about it except contact customer support. Add :increment-metric :rare-errors to let middleware know that it should record that something bad happened. Again! Mark error as :probable-hacking-attempt? true. For example, if you know that a customer only has permission to use tenant A, but is attempting to use tenant B. You are also sure that the UI would never navigate the customer in such a way. Someone is likely trying something. E.g. using curl against your API. Attach :query-too-slow \"SELECT ...\" to help you debug a query that took way too long to execute. Perhaps you cache something first, then check for costly constraints? If you find out that there is an error, you might want to let the middleware know to invalidate the cache in case of an error: :invalidate-cache :cart. Add :origin :service-b to make it clear that service A called B and B returned errors. The code in A is now dealing with errors from :service-b. Alternatively, add :origin-chain [:service-x :service-y :service-z] to indicate a bunch of services failed before reaching :service-a. Add :at-fault to indicate who’s at fault. Was it: :client (web/mobile/desktop application) or :server? This information can be used to influence the default HTTP status code. E.g. 4xx vs. 500. Mark error as :log? false to indicate that logging middleware should not log this error. Perhaps because it contains sensitive information. E.g. user credentials. In a later blog post, we’ll inject a bunch of information that’s available when using malli to validate the input. It’s all about carrying the information until some code higher up can decide what to do with it. This is one of the ways to get to immutable core, imperative shell you might have heard about.\nDefining the model is one thing. How might we implement it? Does the model have any useful operations? Well, yes. See the appendix below for one possible implementation. Feel free to use it and adapt it to your situation.\nHow to use it? Now that we have the error model, implementation, and some useful operations (see appendix below), how do we use it? I need a whole new blog post for this. Stay tuned for part 3.\nFor now, just remember that the goal is for the project to use only errors (or however you’ve defined your model). If something external (library, service, etc.) is representing an error then convert it first into your own model.\nFor the most part, leave exceptional situations (e.g. IOException, SocketException, SQLException) to some other code to deal with (e.g. ring middleware). I’m not suggesting you start wrapping every function or Java method that can throw an exception. This is about representing validation errors and the like. Mostly about what we thought about in part 1.\nSummary Don’t let someone else define your error model. It’s too important. You know what your project needs, so tailor it to your situation. Write your own and base everything on top of it.\nYou want to be in the business of creating information. Some other code is then going to decide to do something based on that information + a lot more from the surrounding context. E.g. HTTP request, response, caught exception, project configuration, etc.\nAppendix We’ll see how to use this properly in part 3. However, here are a few (crude) usage examples.\n;; creating errors (errors/make-1 {:code :maintenance/in-progress}) (errors/make-1 {:code :country/not-found :args [country]}) (errors/make [{:code :headquarters/not-found :args [country] :headquarters (available-headquarters)} {:code :country/embargoed :args [country] :country country} {:code :country/too-far-away :supported-time-zones (supported-time-zones) :increment-metric [:need-to-expand-in country]}]) ;; in authentication middleware (let [errors (validate-authentication request)] (errors/set-suggested-http-code 401 errors)) ;; in exception middleware (very simplified), assuming: ;; - `unwrap-ex` creates `errors` from any exception ;; - `get-message-tpls` returns message templates. See `resources/error-templates.edn` above ;; - `-\u003eerrors-body` creates HTTP response body from `errors` (defn wrap-exception [handler] (fn [request] (try (handler request) (catch Exception ex (let [errors (-\u003e\u003e ex (unwrap-ex) (errors/with-message (get-message-tpls)))] {:status (or (errors/suggested-http-code errors) 400) :body (-\u003eerrors-body errors)}))))) https://github.com/funcool/buddy-sign/blob/3.4.333/src/buddy/sign/jwt.clj#L22 ↩︎\n","wordCount":"2203","inLanguage":"en","datePublished":"2022-12-10T15:25:38+01:00","dateModified":"2022-12-10T15:25:38+01:00","author":{"@type":"Person","name":"Miro Bezjak"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mbezjak.github.io/posts/error-model/"},"publisher":{"@type":"Organization","name":"Well Organized Bits","logo":{"@type":"ImageObject","url":"https://mbezjak.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mbezjak.github.io accesskey=h title="Well Organized Bits (Alt + H)">Well Organized Bits</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mbezjak.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=mailto:well.organized.bits@proton.me title=Contact><span>Contact</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mbezjak.github.io>Home</a>&nbsp;»&nbsp;<a href=https://mbezjak.github.io/posts/>Posts</a></div><h1 class=post-title>Error Model</h1><div class=post-meta><span title='2022-12-10 15:25:38 +0100 +0100'>December 10, 2022</span>&nbsp;·&nbsp;Miro Bezjak&nbsp;|&nbsp;<a href=https://github.com/mbezjak/mbezjak.github.io/blob/main/content/posts/error-model.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>In <a href=../what-is-a-validation>part 1</a> we talked about the various tasks that can
result in an error. Libraries can help with those tasks. However, there is still
a whole bunch that the project will have to take care of. Let&rsquo;s continue from
there. Here we&rsquo;ll concentrate on the error model - the way the errors are
represented. What is that about?</p><p>Each library pulled in to help with the validation tasks represents errors in
its own way. The code you write in the project has even more ways to do the
same. Let&rsquo;s see a couple of examples of what that might look like.</p><ul><li>A function might throw a Java exception (e.g.
<code>java.lang.IllegalArgumentException</code>) thus representing an error as a string
message.</li><li>A function might throw an <code>clojure.lang.ExceptionInfo</code> (via <code>ex-info</code>) thus
representing an error as a string + hash map (via <code>ex-data</code>).</li><li>A function might return <code>true</code>/<code>false</code> to indicate an error.</li><li>A function might return an error message.</li><li>A function might return a collection of error messages.</li><li><code>malli.core/explain</code> returns a hash map with <code>:errors</code> being a list of hash
maps.</li><li><code>malli.error/humanize</code> returns a hash map of path -> vector of messages.</li><li><code>clojure.spec.alpha/explain-data</code> returns a hash map with <code>:problems</code> being a
vector of hash maps.</li><li><code>buddy.sign.jwt/unsign</code> throws <code>ex-info</code> with <code>ex-data</code> having <code>:cause</code>. <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li>Calling an external service might return zero, one or many errors when it
didn&rsquo;t succeed, but in what format? JSON (or something similar) might be
preferable, but the service might respond in HTML as well.</li><li>A function might return a pair <code>[error result]</code> with <code>error</code> being anything
from above.</li><li>etc.</li></ul><p>Having to deal with a large subset of the above makes working on the project
unnecessarily hard. It&rsquo;s even harder when needing to collect multiple errors
from multiple sources all using their own error model.</p><p>What would make it easy is to have just one error model used throughout the
project. Preferably the one that best suits your project and that you can
control to make sure it will work best in the future as well. That seems easy
enough in Clojure. Just define your own error model and base everything on top
of it, wrapping libraries and external services if necessary.</p><h2 id=in-search-of-a-model>In search of a model<a hidden class=anchor aria-hidden=true href=#in-search-of-a-model>#</a></h2><p>Pick a model that is generic enough to be able to represent any error your
project produces and can represent errors from the libraries you&rsquo;re using while
still not being so involved that it makes it cumbersome to use.</p><p>How might we represent an error?</p><p>Let&rsquo;s start simple. An error message as a string.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>validate [country]
</span></span><span style=display:flex><span>  (when-not (<span style=color:#a6e22e>country-exists?</span> country)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>format</span> <span style=color:#e6db74>&#34;Country with code &#39;%s&#39; doesn&#39;t exist&#34;</span> country)))
</span></span></code></pre></div><p>A bit too simplistic? What if we want to attach <code>country</code> with the error? So,
perhaps a hash map?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>validate [country]
</span></span><span style=display:flex><span>  (when-not (<span style=color:#a6e22e>country-exists?</span> country)
</span></span><span style=display:flex><span>    {<span style=color:#e6db74>:message</span> (<span style=color:#a6e22e>format</span> <span style=color:#e6db74>&#34;Country &#39;%s&#39; doesn&#39;t exist&#34;</span> country)
</span></span><span style=display:flex><span>     <span style=color:#e6db74>:country</span> country}))
</span></span></code></pre></div><p>A bit better, but what if we want to represent multiple errors, not just one?
Perhaps a collection of hash maps?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>validate [country]
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>let </span>[errors [(when-not (<span style=color:#a6e22e>headquarters-in?</span> country)
</span></span><span style=display:flex><span>                  {<span style=color:#e6db74>:message</span> (<span style=color:#a6e22e>format</span> <span style=color:#e6db74>&#34;I&#39;m sorry, we don&#39;t have company headquarters in %s&#34;</span> country)
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>:headquarters</span> (<span style=color:#a6e22e>available-headquarters</span>)})
</span></span><span style=display:flex><span>                (when (<span style=color:#a6e22e>embargoed?</span> country)
</span></span><span style=display:flex><span>                  {<span style=color:#e6db74>:message</span> (<span style=color:#a6e22e>format</span> <span style=color:#e6db74>&#34;Sorry, by law we aren&#39;t allowed to conduct business in %s&#34;</span> country)
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>:country</span> country})
</span></span><span style=display:flex><span>                (when (<span style=color:#a6e22e>too-far-away?</span> country)
</span></span><span style=display:flex><span>                  {<span style=color:#e6db74>:message</span> <span style=color:#e6db74>&#34;You are too far away from us&#34;</span>
</span></span><span style=display:flex><span>                   <span style=color:#e6db74>:supported-time-zones</span> (<span style=color:#a6e22e>supported-time-zones</span>)})]]
</span></span><span style=display:flex><span>    (remove nil? errors)))
</span></span></code></pre></div><p>What about grouping errors together? Sure, if you need it. Continue on your own
from here. Just remember not to overcomplicate the model. You&rsquo;ll have to work
with it regularly.</p><p>A few notes to keep in mind:</p><ul><li>This post is about defining the model within your programming language.
Clojure is used here, but the same idea can be applied elsewhere.</li><li>It&rsquo;s not really about the HTTP response body. Although an identical model can
be used for responses as well. Depending on the situation, the error hash map
might be trimmed down to only the essentials (e.g. for public endpoints) or
only slightly trimmed (e.g. for internal service-to-service communication).</li><li>It&rsquo;s not really about the database model. It&rsquo;s mostly about the in-memory
error model. Although, nothing is stopping you from saving errors to the DB if
you have that requirement.</li><li>When you decide on an error model, it can be used with exception throwing
(<code>ex-info</code>) if you don&rsquo;t want to simply return errors.</li></ul><h2 id=model-that-works-well-enough>Model that works well enough<a hidden class=anchor aria-hidden=true href=#model-that-works-well-enough>#</a></h2><p>Here is one possible model that worked quite well for me for years.</p><p>The model:</p><ul><li><code>error</code> is a hash map</li><li><code>errors</code> is a vector of <code>error</code></li></ul><p>That&rsquo;s it. It&rsquo;s simple, quite readable, and very extensible. The project
recognizes a couple of known error keys such as <code>:message</code>, <code>:code</code>, <code>:args</code>,
etc. However, at any point, for any reason, it allows the code to attach other
keys to carry additional information. Presumably with the intent that some
upstream code will use it. How exactly is up to you and the project you&rsquo;re
working on:</p><ul><li>respond with it to an HTTP request</li><li>handle it in an exception middleware (ring)</li><li>save it to the DB</li><li>add it to the queue</li><li>log the event to ElasticSearch</li><li>collect as metric</li><li>etc.</li></ul><p>Here are the project-wide keys that are used most often.</p><h3 id=message>message<a hidden class=anchor aria-hidden=true href=#message>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>{<span style=color:#e6db74>:message</span> <span style=color:#e6db74>&#34;Country with code &#39;XA&#39; doesn&#39;t exist&#34;</span>}
</span></span></code></pre></div><p>This is the simplest variant that&rsquo;s the easiest to understand. It simply encodes
an error message indented for a human. That doesn&rsquo;t necessarily mean a customer.
Perhaps you&rsquo;re the one that&rsquo;s going to be reading it from logs. Or perhaps it&rsquo;s
indented for another person within your organization.</p><p>I don&rsquo;t use it much. I find <code>:code</code> and <code>:args</code> much more advantageous.</p><h3 id=code-and-args>code and args<a hidden class=anchor aria-hidden=true href=#code-and-args>#</a></h3><p>Instead of embedding the error message directly, we can let some other code deal
with constructing the message, but at the point of creating an error, we simply
want to refer to the eventual message. It looks like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>{<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:country/not-found</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:args</span> [country-code2]}
</span></span></code></pre></div><p>Where <code>country-code2</code> is probably in a <code>let</code> binding. This has a couple of
advantages:</p><ul><li><p>It facilitates service-to-service communication. If service A calls B and B
responds with errors, it&rsquo;s easier to deal with the error code rather than a
message intended for a human. Perhaps A needs to execute a different code path
depending on if B responds with a specific error code. Information is easier
to deal with than fishing out the relevant part with <code>re-find</code>.</p></li><li><p>You can let error messages live in an externalized EDN file (or Java
properties, etc.). That way, all error messages for the project are in one
place instead of being spread all over the code base. It also frees the code
base from needing to concatenate strings together. Instead, a ring middleware
might simply execute <code>(apply format template args)</code> once it reads the message
template. An example EDN file is just a hash map from the error code to the
error template.</p><p><code>resources/error-templates.edn</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>{<span style=color:#e6db74>:country/not-found</span> <span style=color:#e6db74>&#34;Country with code &#39;%s&#39; doesn&#39;t exist&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:transaction/insufficient-funds</span> <span style=color:#e6db74>&#34;Not enough funds in the bank account (%s) for money transfer. Available amount: %s. Needed amount: %s&#34;</span>}
</span></span></code></pre></div></li><li><p>It aids in translating error messages into other natural languages (German,
Spanish, etc.). The solution might be similar to <code>error-templates.edn</code> or it
could be much more involved. It depends on your project and what you need to
solve. What&rsquo;s important is for the error to carry the information until some
code higher up can decide what to do with it. Perhaps it needs
<code>Accept-Language</code> from HTTP headers?</p></li></ul><h3 id=breadcrumbs>breadcrumbs<a hidden class=anchor aria-hidden=true href=#breadcrumbs>#</a></h3><p>Path to the source that caused the error. For example, for a deeply nested
structure that might be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>{<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:malli/required</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:breadcrumbs</span> [<span style=color:#e6db74>:customer</span> <span style=color:#e6db74>:address</span> <span style=color:#e6db74>:country</span> <span style=color:#e6db74>:code</span>]}
</span></span></code></pre></div><h3 id=suggested-http-code>suggested-http-code<a hidden class=anchor aria-hidden=true href=#suggested-http-code>#</a></h3><p>How to influence the HTTP response status code? Most of the time the default
would be your favorite HTTP status code when an error occurs. What are you
using: 400, 409, 412, 422? Sometimes, however, you want to explicitly define the
status code. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>{<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:jwt/expired</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>:suggested-http-code</span> <span style=color:#ae81ff>401</span>}
</span></span></code></pre></div><p>Theoretically this can be ambiguous if <code>errors</code> are:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>[{<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:jwt/expired</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:suggested-http-code</span> <span style=color:#ae81ff>401</span>}
</span></span><span style=display:flex><span> {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:produt/not-found</span>
</span></span><span style=display:flex><span>  <span style=color:#e6db74>:suggested-http-code</span> <span style=color:#ae81ff>404</span>}]
</span></span></code></pre></div><p>However, I haven&rsquo;t seen that ambiguity in practice. Mostly because the example
above doesn&rsquo;t make sense. If authentication fails then the middleware responds
to an HTTP request immediately instead of executing more code. Same with other
errors that want to suggest an HTTP code.</p><h3 id=other-ideas>Other ideas<a hidden class=anchor aria-hidden=true href=#other-ideas>#</a></h3><p>Here are some more ideas for you to think about and maybe try.</p><ul><li>Add <code>:severity</code> to describe how important is this error. Values might be
<code>:fatal</code>, <code>:warning</code>, <code>:note</code>, &mldr;</li><li>Add <code>:module</code> and make error messages like &ldquo;Amount is required&rdquo; a bit less
ambiguous. What module produced this error? Was it: transaction, cart, order,
warehouse, &mldr;?</li><li>Most of the time, I let exceptions flow all the way to the ring exception
middleware because it has the most information on how to react. Sometimes,
however, it&rsquo;s nice to be able to catch it and return it as an error. Perhaps
you want to attach the cause as <code>:exception</code>?</li><li>Add <code>:response</code> if service A called service B and B failed to do its job
properly. Your REPL experience will be much nicer if you can see and interact
with that information instead of just throwing it away.</li><li>If any error occurs you&rsquo;ll likely want to trigger a DB rollback. Sometimes you
might not want to do this. Add <code>:transaction-rollback? false</code> to indicate it
to the higher-up code.</li><li>Add <code>:contact-support? true</code> to let UI know and present a special screen to
the customer. The error is such that the customer can do nothing about it
except contact customer support.</li><li>Add <code>:increment-metric :rare-errors</code> to let middleware know that it should
record that something bad happened. Again!</li><li>Mark error as <code>:probable-hacking-attempt? true</code>. For example, if you know that
a customer only has permission to use tenant A, but is attempting to use
tenant B. You are also sure that the UI would never navigate the customer in
such a way. Someone is likely trying something. E.g. using <code>curl</code> against your
API.</li><li>Attach <code>:query-too-slow "SELECT ..."</code> to help you debug a query that took way
too long to execute.</li><li>Perhaps you cache something first, then check for costly constraints? If you
find out that there is an error, you might want to let the middleware know to
invalidate the cache in case of an error: <code>:invalidate-cache :cart</code>.</li><li>Add <code>:origin :service-b</code> to make it clear that service A called B and B
returned errors. The code in A is now dealing with errors from <code>:service-b</code>.
Alternatively, add <code>:origin-chain [:service-x :service-y :service-z]</code> to
indicate a bunch of services failed before reaching <code>:service-a</code>.</li><li>Add <code>:at-fault</code> to indicate who&rsquo;s at fault. Was it: <code>:client</code>
(web/mobile/desktop application) or <code>:server</code>? This information can be used to
influence the default HTTP status code. E.g. 4xx vs. 500.</li><li>Mark error as <code>:log? false</code> to indicate that logging middleware should not log
this error. Perhaps because it contains sensitive information. E.g. user
credentials.</li><li>In a <a href=../errors-from-libraries>later blog post</a>, we&rsquo;ll inject a bunch of
information that&rsquo;s available when using malli to validate the input.</li></ul><p>It&rsquo;s all about carrying the information until some code higher up can decide
what to do with it. This is one of the ways to get to immutable core, imperative
shell you might have heard about.</p><p>Defining the model is one thing. How might we implement it? Does the model have
any useful operations? Well, yes. See the appendix below for one possible
implementation. Feel free to use it and adapt it to your situation.</p><h2 id=how-to-use-it>How to use it?<a hidden class=anchor aria-hidden=true href=#how-to-use-it>#</a></h2><p>Now that we have the error model, implementation, and some useful operations
(see appendix below), how do we use it? I need a whole new blog post for this.
Stay tuned for <a href=../using-the-error-model>part 3</a>.</p><p>For now, just remember that the goal is for the project to use only <code>errors</code> (or
however you&rsquo;ve defined your model). If something external (library, service,
etc.) is representing an error then convert it first into your own model.</p><p>For the most part, leave exceptional situations (e.g. IOException,
SocketException, SQLException) to some other code to deal with (e.g. ring
middleware). I&rsquo;m not suggesting you start wrapping every function or Java method
that can throw an exception. This is about representing validation errors and
the like. Mostly about what we thought about in <a href=../what-is-a-validation>part
1</a>.</p><h2 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h2><p>Don&rsquo;t let someone else define your error model. It&rsquo;s too important. You know
what your project needs, so tailor it to your situation. Write your own and base
everything on top of it.</p><p>You want to be in the business of creating information. Some other code is then
going to decide to do something based on that information + a lot more from the
surrounding context. E.g. HTTP request, response, caught exception, project
configuration, etc.</p><h2 id=appendix>Appendix<a hidden class=anchor aria-hidden=true href=#appendix>#</a></h2><p><script type=application/javascript src="https://gist.github.com/mbezjak/c1baeece563b8ed734692938e6d1a36f.js?file=error.clj"></script>
<script type=application/javascript src="https://gist.github.com/mbezjak/c1baeece563b8ed734692938e6d1a36f.js?file=errors.clj"></script></p><p>We&rsquo;ll see how to use this properly in <a href=../using-the-error-model>part 3</a>.
However, here are a few (crude) usage examples.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span><span style=color:#75715e>;; creating errors</span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>errors/make-1</span> {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:maintenance/in-progress</span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>errors/make-1</span> {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:country/not-found</span>
</span></span><span style=display:flex><span>                <span style=color:#e6db74>:args</span> [country]})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>errors/make</span> [{<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:headquarters/not-found</span>
</span></span><span style=display:flex><span>               <span style=color:#e6db74>:args</span> [country]
</span></span><span style=display:flex><span>               <span style=color:#e6db74>:headquarters</span> (<span style=color:#a6e22e>available-headquarters</span>)}
</span></span><span style=display:flex><span>              {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:country/embargoed</span>
</span></span><span style=display:flex><span>               <span style=color:#e6db74>:args</span> [country]
</span></span><span style=display:flex><span>               <span style=color:#e6db74>:country</span> country}
</span></span><span style=display:flex><span>              {<span style=color:#e6db74>:code</span> <span style=color:#e6db74>:country/too-far-away</span>
</span></span><span style=display:flex><span>               <span style=color:#e6db74>:supported-time-zones</span> (<span style=color:#a6e22e>supported-time-zones</span>)
</span></span><span style=display:flex><span>               <span style=color:#e6db74>:increment-metric</span> [<span style=color:#e6db74>:need-to-expand-in</span> country]}])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; in authentication middleware</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>let </span>[errors (<span style=color:#a6e22e>validate-authentication</span> request)]
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>errors/set-suggested-http-code</span> <span style=color:#ae81ff>401</span> errors))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; in exception middleware (very simplified), assuming:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; - `unwrap-ex` creates `errors` from any exception</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; - `get-message-tpls` returns message templates. See `resources/error-templates.edn` above</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;; - `-&gt;errors-body` creates HTTP response body from `errors`</span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>wrap-exception [handler]
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>fn </span>[request]
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>try</span>
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>handler</span> request)
</span></span><span style=display:flex><span>      (<span style=color:#a6e22e>catch</span> Exception ex
</span></span><span style=display:flex><span>        (<span style=color:#66d9ef>let </span>[errors (<span style=color:#a6e22e>-&gt;&gt;</span> ex (<span style=color:#a6e22e>unwrap-ex</span>) (<span style=color:#a6e22e>errors/with-message</span> (<span style=color:#a6e22e>get-message-tpls</span>)))]
</span></span><span style=display:flex><span>          {<span style=color:#e6db74>:status</span> (or (<span style=color:#a6e22e>errors/suggested-http-code</span> errors) <span style=color:#ae81ff>400</span>)
</span></span><span style=display:flex><span>           <span style=color:#e6db74>:body</span> (<span style=color:#a6e22e>-&gt;errors-body</span> errors)})))))
</span></span></code></pre></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://github.com/funcool/buddy-sign/blob/3.4.333/src/buddy/sign/jwt.clj#L22>https://github.com/funcool/buddy-sign/blob/3.4.333/src/buddy/sign/jwt.clj#L22</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://mbezjak.github.io>Well Organized Bits</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>